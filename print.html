<!DOCTYPE HTML>
<html lang="zh-Hans" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux x86_64系统调用简介</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">序</a></li><li class="chapter-item expanded affix "><a href="src/introduction.html">基础知识</a></li><li class="chapter-item expanded affix "><li class="part-title">文件系统</li><li class="chapter-item expanded "><a href="src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><strong aria-hidden="true">1.</strong> open, openat, name_to_handle_at, open_by_handle_at, open_tree</a></li><li class="chapter-item expanded "><a href="src/filesystem/close.html"><strong aria-hidden="true">2.</strong> close</a></li><li class="chapter-item expanded "><a href="src/filesystem/read-pread64-readv-preadv-preadv2.html"><strong aria-hidden="true">3.</strong> read, pread64, readv, preadv, preadv2</a></li><li class="chapter-item expanded "><a href="src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><strong aria-hidden="true">4.</strong> write, pwrite64, writev, pwritev, pwritev2</a></li><li class="chapter-item expanded "><a href="src/filesystem/lseek.html"><strong aria-hidden="true">5.</strong> lseek</a></li><li class="chapter-item expanded "><a href="src/filesystem/poll-select-pselect6-ppoll.html"><strong aria-hidden="true">6.</strong> poll, select, pselect6, ppoll</a></li><li class="chapter-item expanded "><a href="src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><strong aria-hidden="true">7.</strong> epoll_create, epoll_wait, epoll_ctl, epoll_pwait, epoll_create1</a></li><li class="chapter-item expanded "><a href="src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><strong aria-hidden="true">8.</strong> stat, fstat, lstat, newfstatat, statx</a></li><li class="chapter-item expanded "><a href="src/filesystem/eventfd-eventfd2.html"><strong aria-hidden="true">9.</strong> eventfd, eventfd2</a></li><li class="chapter-item expanded affix "><li class="part-title">内存管理</li><li class="chapter-item expanded "><a href="src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><strong aria-hidden="true">10.</strong> mmap, munmap, mremap, msync, remap_file_pages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Linux x86_64系统调用简介</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-x86_64系统调用简介"><a class="header" href="#linux-x86_64系统调用简介">Linux x86_64系统调用简介</a></h1>
<p>如果要对Linux上的恶意软件进行细致地分析，或者想了解Linux内核，又或是想对Linux内核做进一步的定制，那么了解Linux的全部系统调用就是一个很好的帮助。在分析Linux上的恶意软件时，如果对Linux的系统调用不了解，那么往往会忽视某些重要的关键细节。因此，在充分了解Linux的系统调用之后，就能做到有的放矢，更好地达到我们的需求。</p>
<p>本仓库将详细记录每个Linux x86_64系统调用的功能、用法与实现细节。</p>
<h2 id="环境"><a class="header" href="#环境">环境</a></h2>
<p>所有实现细节均基于<a href="https://github.com/torvalds/linux/tree/v5.4">v5.4版本的Linux内核</a>，glibc-2.31版本的glibc。所记录的系统调用列表位于Linux内核源码的<code>arch/x86/entry/syscalls/syscall_64.tbl</code>。功能、用法基于其相应的manual page，可在<a href="https://www.man7.org/linux/man-pages/">man7.org</a>中查看。涉及到验证代码的，则会在Ubuntu 20.04中进行验证。</p>
<p>如果仅想阅读本仓库的文章以及相应的测试代码，可以使用</p>
<pre><code class="language-shell">git clone git@github.com:Evian-Zhang/introduction-to-linux-x86_64-syscall.git
</code></pre>
<p>如果想同时把相应版本的Linux内核源码与glibc源码一并下载，可以使用</p>
<pre><code class="language-shell">git clone --recurse-submodules git@github.com:Evian-Zhang/introduction-to-linux-x86_64-syscall.git
</code></pre>
<p>对于在国内的网友，可以考虑使用清华大学开源软件镜像站：</p>
<pre><code class="language-shell">git clone git@github.com:Evian-Zhang/introduction-to-linux-x86_64-syscall.git
cd introduction-to-linux-x86_64-syscall
git config submodule.linux.url https://mirrors.tuna.tsinghua.edu.cn/git/linux.git
git config submodule.glibc.url https://mirrors.tuna.tsinghua.edu.cn/git/glibc.git
git pull --recurse-submodules
</code></pre>
<h2 id="构建"><a class="header" href="#构建">构建</a></h2>
<p>请安装<a href="https://github.com/rust-lang/mdBook">mdBook</a>后，在项目根目录下使用</p>
<pre><code class="language-shell">mdbook build
</code></pre>
<p>请注意，如果您使用了<code>--recurse-submodules</code>命令克隆本仓库，从而在本地仓库中包含了全部的Linux和glibc源码，请不要使用上述命令构建。因为<code>mdBook</code>目前会将项目根目录中所有的文件都拷贝进输出的构建目录中。</p>
<h2 id="系统调用对照表"><a class="header" href="#系统调用对照表">系统调用对照表</a></h2>
<p>每个系统调用名都超链接到了其在本仓库中对应的文章。</p>
<table><thead><tr><th>名称</th><th>系统调用号</th><th>头文件</th><th>内核实现</th></tr></thead><tbody>
<tr><td><a href="src/filesystem/read-pread64-readv-preadv-preadv2.html"><code>read</code></a></td><td>0</td><td><code>unistd.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><code>write</code></a></td><td>1</td><td><code>unistd.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><code>open</code></a></td><td>2</td><td><code>fcntl.h</code></td><td><code>fs/open.c</code></td></tr>
<tr><td><a href="src/filesystem/close.html"><code>close</code></a></td><td>3</td><td><code>unistd.h</code></td><td><code>fs/open.c</code></td></tr>
<tr><td><a href="src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><code>stat</code></a></td><td>4</td><td><code>sys/stat.h</code></td><td><code>fs/stat.c</code></td></tr>
<tr><td><a href="src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><code>fstat</code></a></td><td>5</td><td><code>sys/stat.h</code></td><td><code>fs/stat.c</code></td></tr>
<tr><td><a href="src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><code>lstat</code></a></td><td>6</td><td><code>sys/stat.h</code></td><td><code>fs/stat.c</code></td></tr>
<tr><td><a href="src/filesystem/poll-select-pselect6-ppoll.html"><code>poll</code></a></td><td>7</td><td><code>poll.h</code></td><td><code>fs/select.c</code></td></tr>
<tr><td><a href="src/filesystem/lseek.html"><code>lseek</code></a></td><td>8</td><td><code>unistd.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><code>mmap</code></a></td><td>9</td><td><code>sys/mman.h</code></td><td><code>arch/x86/kernel/sys_x86_64.c</code></td></tr>
<tr><td><a href="src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><code>munmap</code></a></td><td>11</td><td><code>sys/mman.h</code></td><td><code>mm/mmap.c</code></td></tr>
<tr><td><a href="src/filesystem/read-pread64-readv-preadv-preadv2.html"><code>pread64</code></a></td><td>17</td><td><code>unistd.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><code>pwrite64</code></a></td><td>18</td><td><code>unistd.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/read-pread64-readv-preadv-preadv2.html"><code>readv</code></a></td><td>19</td><td><code>sys/uio.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><code>writev</code></a></td><td>20</td><td><code>sys/uio.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/poll-select-pselect6-ppoll.html"><code>select</code></a></td><td>23</td><td><code>sys/select.h</code></td><td><code>fs/select.c</code></td></tr>
<tr><td><a href="src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><code>mremap</code></a></td><td>25</td><td><code>sys/mman.h</code></td><td><code>mm/mremap.c</code></td></tr>
<tr><td><a href="src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><code>msync</code></a></td><td>26</td><td><code>sys/mman.h</code></td><td><code>mm/msync.c</code></td></tr>
<tr><td><a href="src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><code>epoll_create</code></a></td><td>213</td><td><code>sys/epoll.h</code></td><td><code>fs/eventpoll.c</code></td></tr>
<tr><td><a href="src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><code>remap_file_pages</code></a></td><td>216</td><td><code>sys/mman.h</code></td><td><code>mm/mmap.c</code></td></tr>
<tr><td><a href="src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><code>epoll_ctl</code></a></td><td>232</td><td><code>sys/epoll.h</code></td><td><code>fs/eventpoll.c</code></td></tr>
<tr><td><a href="src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><code>epoll_wait</code></a></td><td>233</td><td><code>sys/epoll.h</code></td><td><code>fs/eventpoll.c</code></td></tr>
<tr><td><a href="src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><code>openat</code></a></td><td>257</td><td><code>fcntl.h</code></td><td><code>fs/open.c</code></td></tr>
<tr><td><a href="src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><code>newfstatat</code></a></td><td>262</td><td><code>sys/stat.h</code></td><td><code>fs/stat.c</code></td></tr>
<tr><td><a href="src/filesystem/poll-select-pselect6-ppoll.html"><code>pselect6</code></a></td><td>270</td><td><code>sys/select.h</code></td><td><code>fs/select.c</code></td></tr>
<tr><td><a href="src/filesystem/poll-select-pselect6-ppoll.html"><code>ppoll</code></a></td><td>271</td><td><code>poll.h</code></td><td><code>fs/select.c</code></td></tr>
<tr><td><a href="src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><code>epoll_pwait</code></a></td><td>281</td><td><code>sys/epoll.h</code></td><td><code>fs/eventpoll.c</code></td></tr>
<tr><td><a href="src/filesystem/eventfd-eventfd2.html"><code>eventfd</code></a></td><td>284</td><td><code>sys/eventfd.h</code></td><td><code>fs/eventfd.c</code></td></tr>
<tr><td><a href="src/filesystem/eventfd-eventfd2.html"><code>eventfd2</code></a></td><td>290</td><td><code>sys/eventfd.h</code></td><td><code>fs/eventfd.c</code></td></tr>
<tr><td><a href="src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><code>epoll_create1</code></a></td><td>291</td><td><code>sys/epoll.h</code></td><td><code>fs/eventpoll.c</code></td></tr>
<tr><td><a href="src/filesystem/read-pread64-readv-preadv-preadv2.html"><code>preadv</code></a></td><td>295</td><td><code>sys/uio.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><code>pwritev</code></a></td><td>296</td><td><code>sys/uio.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><code>name_to_handle_at</code></a></td><td>303</td><td><code>fcntl.h</code></td><td><code>fs/fhandle.c</code></td></tr>
<tr><td><a href="src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><code>open_by_handle_at</code></a></td><td>304</td><td><code>fcntl.h</code></td><td><code>fs/fhandle.c</code></td></tr>
<tr><td><a href="src/filesystem/read-pread64-readv-preadv-preadv2.html"><code>preadv2</code></a></td><td>327</td><td><code>sys/uio.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><code>pwritev2</code></a></td><td>328</td><td><code>sys/uio.h</code></td><td><code>fs/read_write.c</code></td></tr>
<tr><td><a href="src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><code>statx</code></a></td><td>332</td><td><code>linux/stat.h</code></td><td><code>fs/stat.c</code></td></tr>
<tr><td><a href="src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><code>open_tree</code></a></td><td>428</td><td>无</td><td><code>fs/namespace.c</code></td></tr>
</tbody></table>
<h4 id="license"><a class="header" href="#license">License</a></h4>
<sup>
本仓库遵循<a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0版权协议</a>。
</sup>
<br>
<sub>
作为<a href="https://copyleft.org/">copyleft</a>的支持者之一，我由衷地欢迎大家积极热情地参与到开源社区中。Happy coding!
</sub>
<h1 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h1>
<p>在本仓库中，如无特殊说明，处理器指令集默认为x86_64指令集。</p>
<h2 id="系统调用简介"><a class="header" href="#系统调用简介">系统调用简介</a></h2>
<p>在Linux中，内核提供一些操作的接口给用户态的程序使用，这就是系统调用。对于用户态的程序，其调用相应的接口的方式，是一条汇编指令<code>syscall</code>。</p>
<p>比如说，创建子进程的操作，Linux内核提供了<code>fork</code>这个系统调用作为接口。那么，如果用户态程序想调用这个内核提供的接口，其对应的汇编语句为（部分）</p>
<pre><code class="language-x86asm">movq $57, %rax
syscall
</code></pre>
<p><code>syscall</code>这个指令会先查看此时RAX的值，然后找到系统调用号为那个值的系统调用，然后执行相应的系统调用。我们可以在系统调用列表中找到，<code>fork</code>这个系统调用的系统调用号是57。于是，我们把57放入<code>rax</code>寄存器中，然后使用了<code>syscall</code>指令。这就是让内核执行了<code>fork</code>。</p>
<h2 id="调用约定"><a class="header" href="#调用约定">调用约定</a></h2>
<p>提到这个，就不得不说Linux x86_64的调用约定。我们知道，系统调用往往会有许多参数，比如说<code>open</code>这个打开文件的系统操作，我们可以在<code>include/linux/syscalls.h</code>中找到其对应的C语言接口为</p>
<pre><code class="language-c">asmlinkage long sys_open(const char __user *filename, int flags, umode_t mode);
</code></pre>
<p>它接受三个参数。那么，参数传递是按照什么规定呢？事实上，当涉及到系统调用时，调用约定与用户态程序一般的调用约定并不相同。在<a href="https://gitlab.com/x86-psABIs/x86-64-ABI">System V Application Binary Interface AMD64 Architecture Processor Supplement</a>的A.2.1节中我们可以看到：</p>
<blockquote>
<ol>
<li>User-level applications use as integer registers for passing the sequence <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code> and <code>%r9</code>. The kernel interface uses <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%r10</code>, <code>%r8</code> and <code>%r9</code>.</li>
<li>A system-call is done via the <code>syscall</code> instruction. The kernel destroys registers <code>%rcx</code> and <code>%r11</code>.</li>
<li>The number of the syscall has to be passed in register <code>%rax</code>.</li>
<li>System-calls are limited to six arguments, no argument is passed directly on the stack.</li>
<li>Returning from the syscall, register <code>%rax</code> contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is <code>-errno</code>.</li>
<li>Only values of class INTEGER or class MEMORY are passed to the kernel.</li>
</ol>
</blockquote>
<p>比较重要的是前五点。从这五点我们可以知道，如果要调用<code>open</code>系统调用，那么步骤是：</p>
<ol>
<li>将<code>pathname</code>放入<code>rdi</code>寄存器</li>
<li>将<code>flags</code>放入<code>rsi</code>寄存器</li>
<li>将<code>mode</code>放入<code>rdx</code>寄存器</li>
<li>将<code>open</code>的系统调用号2放入<code>rax</code>寄存器</li>
<li>执行<code>syscall</code>指令</li>
<li>返回值位于<code>rax</code>寄存器</li>
</ol>
<p>我们使用逆向工具查看汇编代码时，就是通过类似以上六步的方法，确定一个系统调用的相关信息的。</p>
<p>这个规范就称为内核接口的调用约定，可以从第一点就显著地看到，这个调用约定与用户态的程序是不同的。也就是说，如果我们用编译器直接编译</p>
<pre><code class="language-c">long sys_open(const char *pathname, int flags, mode_t mode);
</code></pre>
<p>那么，编译出来的可执行程序会认为，这个函数是用户态函数，其传参仍然是按 <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>的顺序，与内核接口不符。因此，gcc提供了一个标签<code>asmlinkage</code>来标记这个函数是内核接口的调用约定：</p>
<pre><code class="language-c">asmlinkage long sys_open(const char *pathname, int flags, mode_t mode);
</code></pre>
<p>当函数前面有这个标签时，编译器编译出的可执行程序就会认为是按内核接口的调用约定对这个函数进行调用的。详情可以看<a href="https://kernelnewbies.org/FAQ/asmlinkage">FAQ/asmlinkage</a>。</p>
<h2 id="glibc封装"><a class="header" href="#glibc封装">glibc封装</a></h2>
<p>当然，我们平时写的代码中，99%不会直接用到上述的系统调用方法。当我们真的去写一个C程序时：</p>
<pre><code class="language-c">// syscall-wrapper-test.c
#include &lt;unistd.h&gt;

int main() {
    fork();
    return 0;
}
</code></pre>
<p>然后我们将其编译为汇编代码</p>
<pre><code class="language-shell">gcc syscall-wrapper-test.c -S -o syscall-wrapper-test.S
</code></pre>
<p>只能看到这个指令：</p>
<pre><code class="language-x86asm">callq fork
</code></pre>
<p>然后在整个汇编文件中都不会找到<code>fork</code>这个函数的实现。甚至我们如果将其编译为可执行程序</p>
<pre><code class="language-shell">gcc syscall-wrapper-test.c -o syscall-wrapper-test
</code></pre>
<p>然后用逆向工具去反汇编，也会发现整个可执行程序中也不会有<code>fork</code>的实现，同时也不会找到任何对57这个系统调用号进行<code>syscall</code>的代码。</p>
<p>这是因为，我们在Linux上编写的程序，通常都会链接到glibc的动态链接库。我们用</p>
<pre><code class="language-shell">ldd syscall-wrapper-list
</code></pre>
<p>查看其链接的动态链接库，就会看到</p>
<pre><code class="language-plaintext">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6
</code></pre>
<p>而glibc则提供了许多系统调用的封装。这使我们在编写程序的时候，并不需要直接和内核进行交互，而是借用glibc这层封装，更加安全、稳定地使用。关于glibc对系统调用的封装，详情请见官方文档<a href="https://sourceware.org/glibc/wiki/SyscallWrappers">SyscallWrappers</a>。</p>
<p>此外，glibc还提供一个特殊的封装——<code>syscall</code>:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
long syscall(long number, ...);
</code></pre>
<p>这可以看作汇编指令<code>syscall</code>的封装。比如说，我们想自己实现一个<code>open</code>函数：</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;

long my_open(const char *pathname, int flags, mode_t mode) {
    return syscall(SYS_open, pathname, flags, mode);
}
</code></pre>
<p>其中，<code>SYS_open</code>为一个宏，定义在<code>sys/syscall.h</code>头文件中，其值为2，也就是<code>open</code>系统调用的系统调用号。</p>
<p>当然，如果真的想在可执行程序中直接对内核进行系统调用，可以把glibc静态链接：</p>
<pre><code class="language-shell">gcc syscall-wrapper-test.c -static -o syscall-wrapper-test
</code></pre>
<p>然后在<code>syscall-wrapper-test</code>这个可执行程序中就可以看到直接的<code>syscall</code>了。</p>
<p>对glibc的动态链接和静态链接各有利弊。对于恶意软件编写者来说，他们往往倾向于静态链接恶意软件。这是因为，分析者可以轻松地写一个动态链接库，将其使用的glibc中的API hook住，改变其行为，使它达不成目的。而如果静态链接，那么分析者只有通过修改内核等比较麻烦的方案才能改变其行为。而静态链接的坏处则在于，如果简单地使用<code>-static</code>选项进行静态链接，就是把整个库都链接进最终的可执行程序中。这会导致库中许多没有被用到的函数的代码也在可执行程序中，使可执行程序的体积增大。解决方案可以参考gcc的官方文档<a href="https://gcc.gnu.org/onlinedocs/gnat_ugn/Compilation-options.html">Compilation-options</a>。</p>
<h2 id="内核接口"><a class="header" href="#内核接口">内核接口</a></h2>
<p>我们之前提到，在Linux内核中，可以在<code>include/linux/syscalls.h</code>文件中找到系统调用函数的声明（会加上<code>sys_</code>前缀）。而其实现则是使用<code>SYSCALL_DEFINEn</code>这个宏。比如说，我们在<code>fs/open.c</code>中可以看到</p>
<pre><code class="language-c">SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
	/* ... */
}
</code></pre>
<p>这代表：</p>
<ul>
<li>内核提供了一个接口，接受三个参数</li>
<li>这个接口叫<code>open</code></li>
<li>第一个参数的类型是<code>const char __user *</code>，参数名为<code>filename</code></li>
<li>第二个参数的类型是<code>int</code>，参数名是<code>flags</code></li>
<li>第三个参数的类型是<code>umode_t</code>，参数名是<code>mode</code></li>
</ul>
<h1 id="open-openat-name_to_handle_at-open_by_handle_at-open_tree系统调用"><a class="header" href="#open-openat-name_to_handle_at-open_by_handle_at-open_tree系统调用"><code>open</code>, <code>openat</code>, <code>name_to_handle_at</code>, <code>open_by_handle_at</code>, <code>open_tree</code>系统调用</a></h1>
<h2 id="open与openat"><a class="header" href="#open与openat"><code>open</code>与<code>openat</code></a></h2>
<h3 id="系统调用号"><a class="header" href="#系统调用号">系统调用号</a></h3>
<p><code>open</code>为2，<code>openat</code>为257。</p>
<h3 id="函数原型"><a class="header" href="#函数原型">函数原型</a></h3>
<h4 id="内核接口-1"><a class="header" href="#内核接口-1">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_open(const char __user *filename, int flags, umode_t mode);
asmlinkage long sys_openat(int dfd, const char __user *filename, int flags, umode_t mode);
</code></pre>
<h4 id="glibc封装-1"><a class="header" href="#glibc封装-1">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int openat(int dirfd, const char *pathname, int flags);
int openat(int dirfd, const char *pathname, int flags, mode_t mode);
</code></pre>
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<p>我们知道，绝大多数文件相关的系统调用都是直接操作文件描述符（file descriptor），而<code>open</code>和<code>openat</code>这两个系统调用是一种创建文件描述符的方式。<code>open</code>系统调用将打开路径为<code>filename</code>的文件，而<code>openat</code>则将打开相对描述符为<code>dirfd</code>的目录，路径为<code>filename</code>的文件。</p>
<p>详细来说，<code>open</code>和<code>openat</code>的行为是</p>
<ul>
<li><code>filename</code>是绝对路径
<ul>
<li><code>open</code>打开位于<code>filename</code>的文件</li>
<li><code>openat</code>打开位于<code>filename</code>的文件，忽略<code>dirfd</code></li>
</ul>
</li>
<li><code>filename</code>是相对路径
<ul>
<li><code>open</code>打开相对于当前目录，路径为<code>filename</code>的文件</li>
<li><code>openat</code>打开相对于<code>dirfd</code>对应的目录，路径为<code>filename</code>的文件；若<code>dirfd</code>是定义在<code>fcntl.h</code>中的宏<code>AT_FDCWD</code>，则打开相对于当前目录，路径为<code>filename</code>的文件。</li>
</ul>
</li>
</ul>
<p>接着，是“怎么打开”的问题。<code>open</code>和<code>openat</code>的参数<code>flags</code>, <code>mode</code>控制了打开文件的行为（<code>mode</code>详情请见<code>creat</code>系统调用。TODO：增加超链接）。</p>
<h4 id="flags"><a class="header" href="#flags">flags</a></h4>
<p>用于打开文件的标志均定义在<code>fcntl.h</code>头文件中。</p>
<h5 id="文件访问模式标志file-access-mode-flag"><a class="header" href="#文件访问模式标志file-access-mode-flag">文件访问模式标志（file access mode flag）</a></h5>
<ul>
<li>
<p><code>O_RDONLY</code></p>
<p>以只读方式打开。创建的文件描述符不可写。</p>
</li>
<li>
<p><code>O_WDONLY</code></p>
<p>以只写方式打开。创建的文件描述符不可读。</p>
</li>
<li>
<p><code>O_RDWR</code></p>
<p>以读写方式打开。创建的文件描述符既可读也可写。</p>
</li>
<li>
<p><code>O_EXEC</code></p>
<p>以只执行方式打开。创建的文件描述符只可以被执行。只能用于非目录路径。</p>
</li>
<li>
<p><code>O_SEARCH</code></p>
<p>以只搜索方式打开。创建的文件描述符值可以被用于搜索。只能用于目录路径。</p>
</li>
</ul>
<p>POSIX标准要求在打开文件时，必须且只能使用上述标志位中的一个。而glibc的封装则要求在打开文件时，必须且只能使用前三个标志位（只读、只写、读写）中的一个。</p>
<h5 id="文件创建标志file-creation-flag"><a class="header" href="#文件创建标志file-creation-flag">文件创建标志（file creation flag）</a></h5>
<p>文件创建标志控制的是<code>open</code>和<code>openat</code>在打开文件时的行为。部分比较常见的标志位有：</p>
<ul>
<li><code>O_CLOEXEC</code>
<ul>
<li>
<p>文件描述符将在调用<code>exec</code>函数族时关闭。</p>
</li>
<li>
<p>我们知道，当一个Linux进程使用<code>fork</code>创建子进程后，父进程原有的文件描述符也会复制给子进程。而常见的模式是在<code>fork</code>之后使用<code>exec</code>函数族替换当前进程空间。此时，由于替换前的所有变量都不会被继承，所以文件描述符将丢失，而丢失之后就无法关闭相应的文件描述符，造成泄露。如<a href="https://github.com/Evian-Zhang/introduction-to-linux-x86_64-syscall/tree/master/codes/open-cloexec">以下代码</a>：</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fd = open(&quot;./text.txt&quot;, O_RDONLY);
    if (fork() == 0) {
        // child process
        char *const argv[] = {&quot;./child&quot;, NULL};
        execve(&quot;./child&quot;, argv, NULL); // fd left opened
    } else {
        // parent process
        sleep(30);
    }

    return 0;
}
</code></pre>
<p>其中<code>./child</code>在启动30秒后会自动退出。</p>
<p>在启动这个程序之后，我们使用<code>ps -aux | grep child</code>找到<code>child</code>对应的进程ID，然后使用</p>
<pre><code class="language-shell">readlink /proc/xxx/fd/yyy
</code></pre>
<p>查看，其中<code>xxx</code>为进程ID，<code>yyy</code>是<code>fd</code>中的任意一个文件。我们调查<code>fd</code>中的所有文件，一定能发现一个文件描述符对应<code>text.txt</code>。也就是说，在执行<code>execve</code>之后，子进程始终保持着<code>text.txt</code>的描述符，且没有任何方法关闭它。</p>
</li>
<li>
<p>解决这个问题的方法一般有两种：</p>
<ul>
<li>在<code>fork</code>之后，<code>execve</code>之前使用<code>close</code>关闭所有文件描述符。但是如果该进程在此之前创建了许多文件描述符，在这里就很容易漏掉，也不易于维护。</li>
<li>在使用<code>open</code>创建文件描述符时，加入<code>O_CLOEXEC</code>标志位：
<pre><code class="language-c">int fd = open(&quot;./text.txt&quot;, O_RDONLY | O_CLOEXEC);
</code></pre>
通过这种方法，在子进程使用<code>execve</code>时，文件描述符会自动关闭。</li>
</ul>
</li>
</ul>
</li>
<li><code>O_CREAT</code>
<ul>
<li>当<code>filename</code>路径不存在时，创建相应的文件。</li>
<li>使用此标志时，<code>mode</code>参数将作为创建的文件的文件模式标志位。详情请见<code>creat</code>系统调用。TODO: 增加超链接</li>
</ul>
</li>
<li><code>O_EXCL</code>
<ul>
<li>该标志位一般会与<code>O_CREAT</code>搭配使用。</li>
<li>如果<code>filename</code>路径存在相应的文件（包括符号链接），则<code>open</code>会失败。</li>
</ul>
</li>
<li><code>O_DIRECTORY</code>
<ul>
<li>如果<code>filename</code>路径不是一个目录，则失败。</li>
<li>这个标志位是用来替代<code>opendir</code>函数的。TODO: 解释其受拒绝服务攻击的原理。</li>
</ul>
</li>
<li><code>O_TRUNC</code>
<ul>
<li>如果<code>filename</code>路径存在相应的文件，且以写的方式打开（即<code>O_WDONLY</code>或<code>O_RDWR</code>），那么将文件内容清空。</li>
</ul>
</li>
</ul>
<h5 id="文件状态标志file-status-flag"><a class="header" href="#文件状态标志file-status-flag">文件状态标志（file status flag）</a></h5>
<p>文件状态标志控制的是打开文件后的后续IO操作。</p>
<ul>
<li>
<p><code>O_APPEND</code></p>
<ul>
<li>使用此标志位时，在后续每一次<code>write</code>操作前，会将文件偏移移至文件末尾。（详情请见<a href="src/filesystem/./write-pwrite64-writev-pwritev-pwritev2.html">write</a>）。</li>
</ul>
</li>
<li>
<p><code>O_ASYNC</code></p>
<ul>
<li>使用信号驱动的IO。后续的IO操作将立即返回，同时在IO操作完成时发出相应的信号。</li>
<li>这种方式在异步IO模式中较少使用，主要由于这种基于中断的信号处理机制比系统调用的耗费更大，并且无法处理多个文件描述符同时完成IO操作。参考<a href="https://stackoverflow.com/a/6260132/10005095">What's the difference between async and nonblocking in unix socket?</a>。</li>
<li>对正常文件的描述符无效，对套接字等文件描述符有效。</li>
</ul>
</li>
<li>
<p><code>O_NONBLOCK</code></p>
<ul>
<li>
<p>后续的IO操作立即返回，而不是等IO操作完成后返回。</p>
</li>
<li>
<p>对正常文件的描述符无效，对套接字等文件描述符有效。</p>
</li>
<li>
<p>对于以此种方式打开的文件，后续的<code>read</code>和<code>write</code>操作可能会产生特殊的错误——<code>EAGAIN</code>（对于套接字文件还可能产生<code>EWOULDBLOCK</code>）。</p>
<p>这种错误的含义是接下来的读取或写入会阻塞，常见的原因可能是已经读取完毕了，或者写满了。比如说，当客户端发送的数据被服务器端全部读取之后，再次对以非阻塞形式打开的套接字文件进行<code>read</code>操作，就会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>错误。</p>
</li>
</ul>
</li>
<li>
<p><code>O_SYNC</code>与<code>O_DSYNC</code></p>
<ul>
<li>使用<code>O_SYNC</code>时，每一次<code>write</code>操作结束前，都会将文件内容和元信息写入相应的硬件。</li>
<li>使用<code>O_DSYNC</code>时，每一次<code>write</code>操作结束前，都会将文件内容写入相应的硬件（不保证元信息）。</li>
<li>这两种方法可以看作是在每一次<code>write</code>操作后使用<code>fsync</code>。</li>
</ul>
</li>
<li>
<p><code>O_PATH</code></p>
<ul>
<li>仅以文件描述符层次打开相应的文件。</li>
<li>我们使用<code>open</code>和<code>openat</code>打开文件通常有两个目的：一是在文件系统中找到相应的文件，二是打开文件对其内容进行查看或修改。如果传入<code>O_PATH</code>标志位，则只执行第一个目的，不仅耗费更低，同时所需要的权限也更少。</li>
<li>通过<code>O_PATH</code>打开的文件描述符可以传递给<code>close</code>, <code>fchdir</code>, <code>fstat</code>等只在文件层面进行的操作，而不能传递给<code>read</code>, <code>write</code>等需要对文件内容进行查看或修改的操作。</li>
</ul>
</li>
</ul>
<h4 id="其他注意点"><a class="header" href="#其他注意点">其他注意点</a></h4>
<p>此外，还有一些需要注意的。</p>
<p>在新的Linux内核（版本不低于2.26）中，glibc的封装<code>open</code>底层调用的是<code>openat</code>系统调用而不是<code>open</code>系统调用（<code>dirfd</code>为<code>AT_FDCWD</code>）。我们可以在glibc源码的<code>sysdeps/unix/sysv/linux/open.c</code>中看到：</p>
<pre><code class="language-c">int
__libc_open (const char *file, int oflag, ...)
{
  int mode = 0;

  if (__OPEN_NEEDS_MODE (oflag))
    {
      va_list arg;
      va_start (arg, oflag);
      mode = va_arg (arg, int);
      va_end (arg);
    }

  return SYSCALL_CANCEL (openat, AT_FDCWD, file, oflag, mode);
}
</code></pre>
<p><code>open</code>的glibc封装实际上就是系统调用<code>openat(AT_FDCWD, file, oflag, mode)</code>。</p>
<p><code>open</code>和<code>openat</code>返回的是文件描述符（file descriptor），在Linux内核中，还有一个概念为文件描述（file description）。操作系统会维护一张全局的表，记录所有打开的文件的信息，如文件偏移、打开文件的状态标志等。这张全局的表的表项即为文件描述。而文件描述符则是对文件描述的引用。</p>
<p>每一次成功调用<code>open</code>和<code>openat</code>，都会在文件描述表中创建一个新的表项，返回的文件描述符即是对该表项的引用。而我们常见的<code>dup</code>, <code>fork</code>等复制的文件描述符，则会指向同一个文件描述。</p>
<p>文件描述创建之后，不会随着文件路径的修改而修改。也就是说，当我们通过<code>open</code>打开了某个特定路径下的文件，然后我们将该文件移动到别的路径上，我们后续的<code>read</code>, <code>write</code>等操作仍能成功。</p>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<p>我们在使用<code>open</code>和<code>openat</code>时，可以有如下的思考顺序：</p>
<ol>
<li>打开文件的路径是绝对路径还是相对路径
<ul>
<li>绝对路径使用<code>open</code>和<code>openat</code>都可以</li>
<li>对于相对路径而言，如果相对于当前目录，则可以使用<code>open</code>，但大部分情况而言还是<code>openat</code>适用性更广（相对于当前目录可以传递<code>AT_FDCWD</code>给<code>dirfd</code>参数）</li>
</ul>
</li>
<li>打开文件是否需要读、写
<ul>
<li>只需要读，<code>flags</code>加入标志位<code>O_RDONLY</code></li>
<li>只需要写，<code>flags</code>加入标志位<code>O_WDONLY</code></li>
<li>既需要读，又需要写，<code>flags</code>加入标志位<code>O_RDWR</code></li>
</ul>
</li>
<li>对于可能会产生子进程并使用<code>exec</code>函数族的程序，<code>flags</code>加入标志位<code>O_CLOEXEC</code></li>
<li>如果需要对文件进行写入：
<ul>
<li>如果需要在写之前清空文件内容，<code>flags</code>加入标志位<code>O_TRUNC</code></li>
<li>如果需要在文件末尾追加，<code>flags</code>加入标志位<code>O_APPEND</code></li>
<li>如果文件不存在的时候需要创建文件，<code>flags</code>加入标志位<code>O_CREAT</code>，并且传递相应的文件模式标志位给<code>mode</code></li>
</ul>
</li>
</ol>
<p>以下几种都是合理的使用方式：</p>
<pre><code class="language-c">int fd1 = open(filename, O_RDONLY);
int fd2 = open(filename, O_RDWR | O_APPEND);
int fd3 = open(filename, O_WDONLY | O_CLOEXEC | O_TRUNC);
</code></pre>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<p><code>open</code>和<code>openat</code>的实现均位于<code>fs/open.c</code>文件中，与其相关的函数是<code>do_sys_open</code>:</p>
<pre><code class="language-c">long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
	struct open_flags op;
	int fd = build_open_flags(flags, mode, &amp;op);
	struct filename *tmp;

	if (fd)
		return fd;

	tmp = getname(filename);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	fd = get_unused_fd_flags(flags);
	if (fd &gt;= 0) {
		struct file *f = do_filp_open(dfd, tmp, &amp;op);
		if (IS_ERR(f)) {
			put_unused_fd(fd);
			fd = PTR_ERR(f);
		} else {
			fsnotify_open(f);
			fd_install(fd, f);
		}
	}
	putname(tmp);
	return fd;
}
</code></pre>
<p>由其实现可知，无论路径是否一样，<code>flag</code>是否相同，<code>open</code>总会使用新的文件描述符。也就是说：</p>
<pre><code class="language-c">int a = open(&quot;./text.txt&quot;, O_RDONLY);
int b = open(&quot;./text.txt&quot;, O_RDONLY);
</code></pre>
<p>尽管调用参数一样，<code>a</code>和<code>b</code>依然是不同的。</p>
<p>此外，这个函数调用了<code>do_filp_open</code>函数作为真正的操作，而其核心是实现在<code>fs/namei.c</code>的函数<code>path_openat</code>:</p>
<pre><code class="language-c">static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)
{
	struct file *file;
	int error;

	file = alloc_empty_file(op-&gt;open_flag, current_cred());
	if (IS_ERR(file))
		return file;

	if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) {
		error = do_tmpfile(nd, flags, op, file);
	} else if (unlikely(file-&gt;f_flags &amp; O_PATH)) {
		error = do_o_path(nd, flags, file);
	} else {
		const char *s = path_init(nd, flags);
		while (!(error = link_path_walk(s, nd)) &amp;&amp;
			(error = do_last(nd, file, op)) &gt; 0) {
			nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
			s = trailing_symlink(nd);
		}
		terminate_walk(nd);
	}
	if (likely(!error)) {
		if (likely(file-&gt;f_mode &amp; FMODE_OPENED))
			return file;
		WARN_ON(1);
		error = -EINVAL;
	}
	fput(file);
	if (error == -EOPENSTALE) {
		if (flags &amp; LOOKUP_RCU)
			error = -ECHILD;
		else
			error = -ESTALE;
	}
	return ERR_PTR(error);
}
</code></pre>
<p>可见对于大部分情况而言，就是按照符号链接的路径找到最终的文件，然后用<code>do_last</code>打开文件。</p>
<h2 id="name_to_handle_at与open_by_handle_at"><a class="header" href="#name_to_handle_at与open_by_handle_at"><code>name_to_handle_at</code>与<code>open_by_handle_at</code></a></h2>
<h3 id="系统调用号-1"><a class="header" href="#系统调用号-1">系统调用号</a></h3>
<p><code>name_to_handle_at</code>为303，<code>open_by_handle_at</code>为304。</p>
<h3 id="函数原型-1"><a class="header" href="#函数原型-1">函数原型</a></h3>
<h4 id="内核接口-2"><a class="header" href="#内核接口-2">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_name_to_handle_at(int dfd, const char __user *name, struct file_handle __user *handle, int __user *mnt_id, int flag);
asmlinkage long sys_open_by_handle_at(int mountdirfd, struct file_handle __user *handle, int flags);
</code></pre>
<h4 id="glibc封装-2"><a class="header" href="#glibc封装-2">glibc封装</a></h4>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
int name_to_handle_at(int dirfd, const char *pathname, struct file_handle *handle, int *mount_id, int flags);
int open_by_handle_at(int mount_fd, struct file_handle *handle, int flags);
</code></pre>
<h3 id="简介-1"><a class="header" href="#简介-1">简介</a></h3>
<p><code>name_to_handle_at</code>和<code>open_by_handle_at</code>将<code>openat</code>的功能解耦成两部分：</p>
<pre><code class="language-plaintext">filename ----openat----&gt; file descriptor
filename ----name_to_handle_at----&gt; file handle + mount id ----open_by_handle_at----&gt; file descriptor
</code></pre>
<p><code>openat</code>将输入的文件路径转化为文件描述符输出，而<code>name_to_handle_at</code>将输入的文件路径转化为文件句柄和挂载ID输出，而<code>open_by_handle_at</code>将输入的文件句柄和挂载ID转化为文件描述符输出。</p>
<p>这样做看似多此一举，但是在构造无状态的文件服务器时很有用。假设我们的文件服务器是使用<code>openat</code>作为打开文件的方式：</p>
<ol>
<li>方案一
<ul>
<li>步骤
<ol>
<li>服务器告诉客户端文件路径</li>
<li>客户端告诉服务器，想要修改的文件路径，和修改的内容</li>
<li>服务器使用<code>openat</code>打开相应文件路径，然后对文件进行修改</li>
</ol>
</li>
<li>假设服务器告诉客户端我们的文件路径为<code>path/text.txt</code>，在客户端发送修改指令之前，又有另一个客户端将这个文件移动到了<code>path2/text.txt</code>，那么客户端的修改就失败了，因为<code>openat</code>无法打开相应的文件</li>
</ul>
</li>
<li>方案二
<ul>
<li>步骤
<ol>
<li>服务器用<code>openat</code>打开文件路径，告诉客户端文件描述符</li>
<li>客户端告诉服务器，想要修改的文件描述符，和修改的内容</li>
<li>服务器对相应的文件描述符作出相应的修改</li>
</ol>
</li>
<li>由于文件描述符在文件移动后依然有效，所以这么做确实可以避免方案一的问题。但是，我们的服务器就成了一个有状态的服务器。因为程序一旦挂掉，那么所有文件描述符都会失效</li>
</ul>
</li>
</ol>
<p>因此，用<code>openat</code>并不能完美解决无状态文件服务器的问题。但是，我们用<code>name_to_handle_at</code>和<code>open_by_handle_at</code>的方案为：</p>
<ol>
<li>服务器用<code>name_to_handle_at</code>打开文件路径，告诉客户端文件句柄和挂载ID</li>
<li>客户端告诉服务器，想要修改的文件句柄和挂载ID，和修改的内容</li>
<li>服务器使用<code>open_by_handle_at</code>打开相应的文件，获得文件描述符，进行进一步的修改</li>
</ol>
<p>这一方案和方案二看起来很类似，但实际上有一点不同：文件句柄和挂载ID是由操作系统维护的，而不需要服务器维护。也就是说，只要是在同一操作系统中，所有的进程通过文件句柄和挂载ID打开的文件一定相同。</p>
<p><code>name_to_handle_at</code>的具体行为，由<code>dirfd</code>, <code>pathname</code>和<code>flags</code>共同控制：</p>
<ul>
<li>如果<code>pathname</code>是绝对路径，则返回对应的文件句柄和挂载ID，忽略<code>dirfd</code></li>
<li>如果<code>pathname</code>是相对路径，则返回该路径相对于<code>dirfd</code>（若值为<code>AT_FDCWD</code>则是当前目录）对应的文件的文件句柄和挂载ID</li>
<li>如果<code>pathname</code>解析出来是符号链接，且<code>flags</code>包含标志位<code>AT_SYMLINK_FOLLOW</code>，则继续找该符号链接引用的真实文件，并返回真实文件的文件句柄和挂载ID</li>
<li>如果<code>pathname</code>为空字符串，且<code>flags</code>包含控制位<code>AT_EMPTY_PATH</code>，则返回对应于文件描述符<code>dirfd</code>的文件句柄和挂载ID（此时<code>dirfd</code>可以为任意文件类型的描述符，不一定是目录的文件描述符）</li>
</ul>
<p><code>open_by_handle_at</code>的<code>flags</code>则和<code>openat</code>的<code>flags</code>含义相同，为打开文件的方式。</p>
<h3 id="用法-1"><a class="header" href="#用法-1">用法</a></h3>
<p><code>struct file_handle</code>的定义为</p>
<pre><code class="language-c">struct file_handle {
	unsigned int  handle_bytes;
	int           handle_type;
	unsigned char f_handle[0];
};
</code></pre>
<p>其中<code>f_handle</code>字段是变长数组。当我们使用<code>name_to_handle_at</code>时，首先需要将<code>handle</code>的<code>handle_bytes</code>字段置0，传入后，<code>name_to_handle_at</code>将返回-1，同时<code>errno</code>会被置为<code>EOVERFLOW</code>，同时<code>handle</code>的<code>handle_bytes</code>字段会被置为其需要的大小，然后我们再根据这个大小分配相应的空间给<code>handle</code>，再次传入即可：</p>
<pre><code class="language-c">char filename[] = &quot;./text.txt&quot;;
struct file_handle tmp_handle;
tmp_handle.handle_bytes = 0;
if (name_to_handle_at(filename, AT_FDCWD, &amp;tmp_handle, NULL, 0) != -1 || errno != EOVERFLOW) {
	exit(-1); // Unexpected behavior
}
struct file_handle *handle = (struct file_handle *)malloc(tmp_handle.handle_bytes);
handle-&gt;handle_bytes = tmp_handle.handle_bytes;
int mount_id;
name_to_handle_at(filename, AT_FDCWD, handle, &amp;mount_id, 0);
</code></pre>
<p>而<code>open_by_handle_at</code>则相对比较简单：</p>
<pre><code class="language-c">int fd = open_by_handle_at(mount_id, handle, O_RDONLY);
</code></pre>
<h3 id="实现-1"><a class="header" href="#实现-1">实现</a></h3>
<p><code>name_to_handle_at</code>和<code>open_by_handle_at</code>的实现均位于<code>fs/fhandle.c</code>中。<code>name_to_handle_at</code>的核心为位于<code>fs/exportfs/expfs.c</code>中的<code>exportfs_encode_inode_fh</code>:</p>
<pre><code class="language-c">int exportfs_encode_inode_fh(struct inode *inode, struct fid *fid, int *max_len, struct inode *parent)
{
	const struct export_operations *nop = inode-&gt;i_sb-&gt;s_export_op;

	if (nop &amp;&amp; nop-&gt;encode_fh)
		return nop-&gt;encode_fh(inode, fid-&gt;raw, max_len, parent);

	return export_encode_fh(inode, fid, max_len, parent);
}
</code></pre>
<p><code>open_by_handle_at</code>的核心为位于<code>fs/exportfs/expfs.c</code>中的<code>exportfs_decode_fh</code>:</p>
<pre><code class="language-c">struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid, int fh_len, int fileid_type, int (*acceptable)(void *, struct dentry *), void *context)
{
	const struct export_operations *nop = mnt-&gt;mnt_sb-&gt;s_export_op;
	// ...
	result = nop-&gt;fh_to_dentry(mnt-&gt;mnt_sb, fid, fh_len, fileid_type);
	// ...
}
</code></pre>
<p>由此可见，其关键在于<code>export_operations</code>这个结构体。通过位于内核源码<code>Documentation/filesystems/nfs/exporting.rst</code>的文档我们可以知道：</p>
<blockquote>
<p>encode_fh (optional)</p>
<p>Takes a dentry and creates a filehandle fragment which can later be used to find or create a dentry for the same object. The default implementation creates a filehandle fragment that encodes a 32bit inode and generation number for the inode encoded, and if necessary the same information for the parent.</p>
<p>fh_to_dentry (mandatory)</p>
<p>Given a filehandle fragment, this should find the implied object and create a dentry for it (possibly with d_obtain_alias).</p>
</blockquote>
<p>用于产生文件句柄的<code>encode_fh</code>函数指针，其默认实现是和inode直接相关的，所以确实可以看作是由操作系统来维护这个文件句柄的。</p>
<h2 id="open_tree"><a class="header" href="#open_tree"><code>open_tree</code></a></h2>
<h3 id="系统调用号-2"><a class="header" href="#系统调用号-2">系统调用号</a></h3>
<p>428</p>
<h3 id="函数原型-2"><a class="header" href="#函数原型-2">函数原型</a></h3>
<h4 id="内核接口-3"><a class="header" href="#内核接口-3">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_open_tree(int dfd, const char __user *path, unsigned flags);
</code></pre>
<h4 id="glibc封装-3"><a class="header" href="#glibc封装-3">glibc封装</a></h4>
<p>无glibc封装，需要手动调用<code>syscall</code>。</p>
<h3 id="简介-2"><a class="header" href="#简介-2">简介</a></h3>
<p>该系统调用的介绍在网络上较少，可以参考<a href="https://lkml.org/lkml/2018/9/21/884">lkml.org</a>。</p>
<p>我们可以将该系统调用看作包含<code>O_PATH</code>标志位，用<code>open</code>或<code>openat</code>打开。也就是说，只在文件系统中标记该位置，而不打开相应的内容，产生的文件描述符只能供少部分在文件层次进行的操作使用。</p>
<p>当<code>flags</code>包含标志位<code>OPEN_TREE_CLONE</code>时，情况会稍微复杂一些。此时，<code>open_tree</code>会产生一个游离的(detached)挂载树，该挂载树对应的就是<code>dfd</code>和<code>path</code>决定的路径上的子树。如果还包含<code>AT_RECURSIVE</code>标志位，则整个子树都将被复制，否则就只复制目标挂载点内的部分。<code>OPEN_TREE_CLONE</code>标志位可以看作<code>mount --bind</code>，而<code>OPEN_TREE_CLONE | AT_RECURSIVE</code>标志位可以看作<code>mount --rbind</code>。</p>
<h3 id="实现-2"><a class="header" href="#实现-2">实现</a></h3>
<p>位于<code>fs/namespace.c</code>文件中，其核心语句为</p>
<pre><code class="language-c">file = dentry_open(&amp;path, O_PATH, current_cred());
</code></pre>
<p>也就是通过<code>O_PATH</code>标志位打开相应的文件。</p>
<h1 id="close系统调用"><a class="header" href="#close系统调用"><code>close</code>系统调用</a></h1>
<h2 id="系统调用号-3"><a class="header" href="#系统调用号-3">系统调用号</a></h2>
<p>3</p>
<h2 id="函数签名"><a class="header" href="#函数签名">函数签名</a></h2>
<h3 id="内核接口-4"><a class="header" href="#内核接口-4">内核接口</a></h3>
<pre><code class="language-c">asmlinkage long sys_close(unsigned int fd);
</code></pre>
<h3 id="glibc封装-4"><a class="header" href="#glibc封装-4">glibc封装</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;
int close(int fd);
</code></pre>
<h2 id="简介-3"><a class="header" href="#简介-3">简介</a></h2>
<p><code>close</code>系统调用的作用是关闭一个文件描述符，使得其不再指向任何文件，同时该文件描述符也可供后续<code>open</code>等操作复用。</p>
<p><code>close</code>系统调用在我们日常的文件操作中随处可见，功能也相对比较简单。但是，有几点需要注意：</p>
<p>首先，如果我们在<code>open</code>状态下删除（<code>unlink</code>）了某个文件，那对这个文件描述符的<code>close</code>操作的行为，则需要判断该文件被多少个文件描述符所引用。假设<code>close</code>的文件描述符是最后一个引用该文件的描述符，则<code>close</code>操作之后，该文件将被真正意义上的删除。</p>
<p>第二，<code>close</code>并不能确保我们在之前对文件写入的数据一定会写入到硬盘中。正如我们在<a href="src/filesystem/./write-pwrite-writev-pwritev-pwritev2.html"><code>write</code></a>中提到的，如果要确保在<code>close</code>之前数据写入到硬盘，就使用<code>fsync</code>。</p>
<p>第三，<code>close</code>如果失败，则返回-1，并且设置相应的<code>errno</code>。<code>close</code>可能失败的原因比较重要，主要包括：</p>
<ul>
<li><code>EBADF</code>: <code>fd</code>不是一个有效的，处于打开状态的文件描述符</li>
<li><code>EINTR</code>: <code>close</code>操作被信号中断</li>
<li><code>EIO</code>: IO失败</li>
</ul>
<p>虽然<code>close</code>失败后的行为和别的系统调用类似，但比较特殊的是，一般情况下，这种失败只能起到一种“告知”作用，我们不能再次使用<code>close</code>。这是因为在<code>close</code>的实现中，真正实施关闭文件的操作在整个过程的很前面，一般在文件真正关闭之前是不会产生错误的。因此，尽管<code>close</code>出错，但<strong>有可能</strong>这个文件描述符已经被关闭了。此时，再次调用<code>close</code>，如果该文件描述符没有被再次使用，则由于已经被关闭，所以会返回<code>EBADF</code>错误；否则，如果在再次调用<code>close</code>之前，该文件描述符被别的线程复用了，那就会不小心关闭了别的线程的有意义的文件描述符。</p>
<h2 id="实现-3"><a class="header" href="#实现-3">实现</a></h2>
<p><code>close</code>的实现位于<code>fs/open.c</code>中：</p>
<pre><code class="language-c">SYSCALL_DEFINE1(close, unsigned int, fd)
{
	int retval = __close_fd(current-&gt;files, fd);

	/* can't restart close syscall because file table entry was cleared */
	if (unlikely(retval == -ERESTARTSYS ||
		     retval == -ERESTARTNOINTR ||
		     retval == -ERESTARTNOHAND ||
		     retval == -ERESTART_RESTARTBLOCK))
		retval = -EINTR;

	return retval;
}
</code></pre>
<p>可见其核心为位于<code>fs/file.c</code>的<code>__close_fd</code>函数:</p>
<pre><code class="language-c">int __close_fd(struct files_struct *files, unsigned fd)
{
	struct file *file;
	struct fdtable *fdt;

	spin_lock(&amp;files-&gt;file_lock);
	fdt = files_fdtable(files);
	if (fd &gt;= fdt-&gt;max_fds)
		goto out_unlock;
	file = fdt-&gt;fd[fd];
	if (!file)
		goto out_unlock;
	rcu_assign_pointer(fdt-&gt;fd[fd], NULL);
	__put_unused_fd(files, fd);
	spin_unlock(&amp;files-&gt;file_lock);
	return filp_close(file, files);

out_unlock:
	spin_unlock(&amp;files-&gt;file_lock);
	return -EBADF;
}
</code></pre>
<p>从第13行可以看到，最先进行的实际操作是在该进程的文件描述符列表删除该描述符，然后在第16行使用位于<code>fs/open.c</code>的<code>filp_close</code>函数对文件描述符对应的文件做扫尾工作：</p>
<pre><code class="language-c">int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR &quot;VFS: Close: file count is 0\n&quot;);
		return 0;
	}

	if (filp-&gt;f_op-&gt;flush)
		retval = filp-&gt;f_op-&gt;flush(filp, id);

	if (likely(!(filp-&gt;f_mode &amp; FMODE_PATH))) {
		dnotify_flush(filp, id);
		locks_remove_posix(filp, id);
	}
	fput(filp);
	return retval;
}
</code></pre>
<p>其核心也就是第11行的<code>filp-&gt;f_op-&gt;flush</code>，也就是如果文件系统有相应的<code>flush</code>操作，则对文件进行<code>flush</code>。在<code>fs/ext4/file.c</code>的512行就可以看到，我们在Linux中常用的EXT4系统，并没有定义相应的操作。也就是说，这里实际上也没做什么事。</p>
<p>从这个实现中我们可以验证两件事：</p>
<ul>
<li>在<code>close</code>整个过程的早期，文件描述符就已经失效了，不再表示一个有效的打开状态的文件描述符，且在其完成之前基本上不会产生失败。</li>
<li>如果我们<code>flush</code>的操作失败了，是没有机会再次进行<code>flush</code>的，因为文件描述符先前已经失效了。</li>
</ul>
<h1 id="read-pread64-readv-preadv-preadv2系统调用"><a class="header" href="#read-pread64-readv-preadv-preadv2系统调用"><code>read</code>, <code>pread64</code>, <code>readv</code>, <code>preadv</code>, <code>preadv2</code>系统调用</a></h1>
<h2 id="read与pread64"><a class="header" href="#read与pread64"><code>read</code>与<code>pread64</code></a></h2>
<h3 id="系统调用号-4"><a class="header" href="#系统调用号-4">系统调用号</a></h3>
<p><code>read</code>的系统调用号为0, <code>pread64</code>的系统调用号为17。</p>
<h3 id="函数原型-3"><a class="header" href="#函数原型-3">函数原型</a></h3>
<h4 id="内核接口-5"><a class="header" href="#内核接口-5">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_read(unsigned int fd, char __user *buf, size_t count);
asmlinkage long sys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos);
</code></pre>
<h4 id="glibc封装-5"><a class="header" href="#glibc封装-5">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t count);
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
</code></pre>
<h3 id="简介-4"><a class="header" href="#简介-4">简介</a></h3>
<p><code>read</code>和<code>pread</code>是最基础的对文件读取的系统调用。<code>read</code>会从描述符为<code>fd</code>的文件中读取<code>count</code>个字节存入<code>buf</code>中，而<code>pread</code>则是从描述符为<code>fd</code>的文件中，从<code>offset</code>位置开始，读取<code>count</code>个字节存入<code>buf</code>中。如果读取成功，这两个系统调用都将返回读取的字节数。因此，这两个系统调用主要的区别就在于读取的位置，其它功能均类似。</p>
<p>有几点需要注意：</p>
<p>首先，是从哪开始读。<code>pread64</code>没有问题，就是从<code>offset</code>的位置开始读。而对于<code>read</code>，如果它读取的描述符对应的文件支持seek，那么它是从文件描述符中存储的文件偏移（file offset）处继续读。假设我们的文件对应的二进制数据为</p>
<pre><code class="language-plaintext">1F 2E 3D 4C 5B 6A
</code></pre>
<p>我们先是用<code>read</code>读取了3个字节的内容，此时文件因为之前没有被读过，因此文件偏移为0，<code>read</code>将读到<code>1F 2E 3D</code>。然后，文件偏移就被更新为3。那么，我们接下来如果用<code>read</code>读取1个字节的内容，读到的将会是<code>4C</code>。</p>
<p>因此，对于支持seek的文件来说，<code>read</code>是从文件偏移的位置继续读，<code>pread</code>是从<code>offset</code>的位置开始读。</p>
<p>我们知道，更改文件偏移有单独的系统调用<code>lseek</code>，因此，如果我们要从某个特定的位置读取数据，可以<code>lseek</code>+<code>read</code>，也可以<code>pread</code>。但是，系统调用实际上是一个复杂的耗时操作，所以<code>pread</code>就用一次系统调用解决了两个系统调用的问题。</p>
<p>第二，是读多少的问题。<code>read</code>和<code>pread</code>读取的字节数一定不大于<code>count</code>，但有可能小于<code>count</code>。假设说我们的二进制文件只有上述6个字节。那么，如果我们<code>read</code>了8个字节，后2个字节自然是无法被读取的。因此，只能读取到6个字节，<code>read</code>也将返回6。除此之外，还有很多可能会让<code>read</code>和<code>pread</code>读取的字节小于<code>count</code>。比如说，从一个终端读取（输入的字节小于其需求的字节），或者在读取时被某些信号中断。</p>
<p>此外，除了读的字节小于<code>count</code>之外，<code>read</code>和<code>pread</code>还有可能读取失败。此时的返回值将是-1。我们可以用<code>errno</code>查看其错误。文件描述符不可读或无效（<code>EBADF</code>），<code>buf</code>不可使用（<code>EFAULT</code>），文件描述符是目录而非文件（<code>EISDIR</code>）等等，这些都有可能直接造成读取的错误。对于以非阻塞形式打开的文件，还可能返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>，详情请见<a href="src/filesystem/./open-openat-name_to_handle_at-open_by_handle_at-open_tree.html">open</a>。</p>
<p>第三，是读完当<code>read</code>或<code>pread</code>读取结束后的工作。<code>read</code>会更新文件描述符中的文件偏移，它们读了多少字节，就向后移动多少字节。但是，值得注意的是，<code>pread</code>并不会更新文件偏移。<code>pread</code>不更新文件偏移这一点对于多线程的程序来说极其有用。我们知道，多条线程有可能共用同一个文件描述符，但文件偏移是存储在文件描述符中。如果我们在多线程中使用<code>read</code>，会导致文件偏移混乱；但是，如果我们使用<code>pread</code>，则会完满避免这个问题。</p>
<p>第四，是如何读。在Linux的哲学中，如何读并不是<code>read</code>和<code>pread</code>能决定的，而是由文件描述符本身决定的。文件描述符在创建的时候，就决定了它将被如何读取，比如说是否阻塞等等。</p>
<h3 id="用例"><a class="header" href="#用例">用例</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fd = open(&quot;./text.txt&quot;, O_RDONLY);
    if (fd &lt; 0) {
        // open error
        exit(1);
    }
    char buf[64];
    ssize_t read_length = read(fd, buf, 64);
    if (read_length &lt; 0) {
        // read error
        exit(1);
    }
    ssize_t pread_length = pread(fd, buf, 64, 233);
    if (pread_length &lt; 0) {
        // pread error
        exit(1);
    }
    close(fd);
    return 0;
}
</code></pre>
<h3 id="实现-4"><a class="header" href="#实现-4">实现</a></h3>
<p><code>read</code>和<code>pread64</code>的实现均位于<code>fs/read_write.c</code>。这两个系统调用的核心是<code>__vfs_read</code>函数，其实现为</p>
<pre><code class="language-c">ssize_t __vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
	if (file-&gt;f_op-&gt;read)
		return file-&gt;f_op-&gt;read(file, buf, count, pos);
	else if (file-&gt;f_op-&gt;read_iter)
		return new_sync_read(file, buf, count, pos);
	else
		return -EINVAL;
}
</code></pre>
<p>我们可以看到，它实际上是调用了<code>file-&gt;f_op-&gt;read(file, buf, count, pos)</code>函数。也就是我们上面讲到的，<code>read</code>和<code>pread</code>怎么读，是由文件描述符决定的。而第二个条件分支的<code>new_sync_read</code>我们之后会提到。我们可以把这个操作看作是用C实现的C++的多态，<code>file-&gt;f_op-&gt;read</code>是一个函数指针，类似于一个虚函数。每一种文件类型都会定义自己的<code>read</code>的方法，而<code>__vfs_read</code>则是调用了这个虚函数的方法。</p>
<p>总的来说，完成了这个函数之后，就实现了文件读取功能。</p>
<p><code>read</code>和<code>pread64</code>的完整实现也很类似。<code>read</code>的实现主要是在<code>ksys_read</code>函数中，其实现为</p>
<pre><code class="language-c">ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)
{
	struct fd f = fdget_pos(fd);
	ssize_t ret = -EBADF;

	if (f.file) {
		loff_t pos, *ppos = file_ppos(f.file);
		if (ppos) {
			pos = *ppos;
			ppos = &amp;pos;
		}
		ret = vfs_read(f.file, buf, count, ppos);
		if (ret &gt;= 0 &amp;&amp; ppos)
			f.file-&gt;f_pos = pos;
		fdput_pos(f);
	}
	return ret;
}
</code></pre>
<p>可以看到，<code>read</code>会确定当前的文件偏移（第7行），然后从当前的文件偏移开始读取；读取完毕后，更新文件偏移（第14行）。</p>
<p>而<code>pread64</code>的实现主要是在<code>ksys_pread64</code>函数中，其实现为</p>
<pre><code class="language-c">ssize_t ksys_pread64(unsigned int fd, char __user *buf, size_t count, loff_t pos)
{
	struct fd f;
	ssize_t ret = -EBADF;

	if (pos &lt; 0)
		return -EINVAL;

	f = fdget(fd);
	if (f.file) {
		ret = -ESPIPE;
		if (f.file-&gt;f_mode &amp; FMODE_PREAD)
			ret = vfs_read(f.file, buf, count, &amp;pos);
		fdput(f);
	}

	return ret;
}
</code></pre>
<p>可以看到，它与<code>read</code>的实现主要的区别在于，它不需要读取当前的文件偏移，而是直接从<code>pos</code>处开始；读取完毕后，它也不会更新当前的文件偏移。</p>
<h2 id="readv-preadv与preadv2"><a class="header" href="#readv-preadv与preadv2"><code>readv</code>, <code>preadv</code>与<code>preadv2</code></a></h2>
<h3 id="系统调用号-5"><a class="header" href="#系统调用号-5">系统调用号</a></h3>
<p><code>readv</code>为19，<code>preadv</code>为295，<code>preadv2</code>为327。</p>
<h3 id="函数原型-4"><a class="header" href="#函数原型-4">函数原型</a></h3>
<pre><code class="language-c">asmlinkage long sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_preadv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
asmlinkage long sys_preadv2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);
</code></pre>
<p>glibc封装后为</p>
<pre><code class="language-c">#include &lt;sys/uio.h&gt;
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt, off_t offset);
ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags);
</code></pre>
<h3 id="简介-5"><a class="header" href="#简介-5">简介</a></h3>
<p>我们在上面提到，<code>pread</code>除了在多线程中发挥大作用之外，也可以将两次系统调用<code>lseek</code>+<code>read</code>化为一次系统调用。而这一节所讲的系统调用，则是更进一步。<code>read</code>和<code>pread</code>是将文件读取到一块连续内存中，那如果我们想要将文件读取到多块连续内存中（也就是说，有多块内存，内存内部连续，但内存之间不连续），就得多次使用这些系统调用，造成很大的开销。而<code>readv</code>, <code>preadv</code>, <code>preadv2</code>则是为了解决这样的问题。</p>
<p>首先，我们需要知道<code>iovec</code>的定义（位于<code>include/uapi/linux/uio.h</code>）：</p>
<pre><code class="language-c">struct iovec
{
	void __user *iov_base;
	__kernel_size_t iov_len;
};
</code></pre>
<p>这实际上就是<code>read</code>的后两个参数，也就是内存中的目的地址，与需要读取的长度。</p>
<p><code>readv</code>, <code>preadv</code>, <code>preadv2</code>的第二个参数<code>iov</code>是一个<code>iovec</code>结构体组成的数组，其元素个数由第三个参数<code>iovcnt</code>给出。这三个系统调用的作用就是“分散读”（scatter input），将一块连续的文件内容，按顺序读入多块连续区域中。</p>
<p>在<code>preadv</code>和<code>preadv2</code>中，我们可以看到，其系统调用接口含有两个参数<code>pos_l</code>与<code>pos_h</code>，但glibc封装后只有一个参数<code>offset</code>。这是因为，考虑到64位地址的问题，<code>pos_l</code>和<code>pos_h</code>分别包含了<code>offset</code>的低32位和高32位。</p>
<p>此外，还需要注意，这里的读取虽然说是“向量化”，但实际上，缓冲区是按数组顺序处理的，也就是说，只有在<code>iov[0]</code>被填满之后，才会去填充<code>iov[1]</code>。</p>
<p>同样类似<code>read</code>与<code>pread</code>，这三个系统调用也是返回读取的字节数，同样可能会小于<code>iov-&gt;iov_len</code>之和。</p>
<p>与<code>read</code>和<code>pread</code>不同的是，这三个系统调用是原子性的，它们读取的文件内容永远是连续的，也就是说不会因为文件偏移被别的线程改变而混乱。比如说，我们想将文件中的内容读入三块缓冲区中。如果我们是使用三次<code>read</code>，但是在第一次<code>read</code>结束之后，第二次<code>read</code>开始之前，另外一个线程对这个文件描述符的文件偏移进行了改变，那么接下来的两次<code>read</code>读出的数据与第一次<code>read</code>读出的数据是不连续的。但是，如果我们用<code>readv</code>，读出的数据一定是连续的。</p>
<p>而<code>preadv</code>与<code>preadv2</code>的区别，主要在于最后一个参数。它通过一些标志位来改变读取的行为。具体可以看其手册<a href="https://www.man7.org/linux/man-pages/man2/preadv2.2.html">preadv2</a>。</p>
<p>关于文件偏移的更新，<code>readv</code>和<code>read</code>一样，在结束之后会更新文件偏移；<code>preadv</code>和<code>pread</code>一样，在结束之后不会更新文件偏移；对于<code>preadv2</code>来说，如果<code>offset</code>为-1，其会使用当前的文件偏移而不是前往指定的文件偏移，并且在结束后会更新文件偏移，但是如果其不为-1，则不会更新文件偏移。</p>
<h3 id="用例-1"><a class="header" href="#用例-1">用例</a></h3>
<pre><code class="language-c">#include &lt;sys/uio.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fd = open(&quot;./text.txt&quot;, O_RDONLY);
    if (fd &lt; 0) {
        // open error
        exit(1);
    }
    char buf1[64], buf2[32], buf3[128];
    struct iovec iovecs[3];
    iovec[0] = (struct iovec){ .iov_base = buf1, .iov_len = 64 };
    iovec[1] = (struct iovec){ .iov_base = buf2, .iov_len = 32 };
    iovec[2] = (struct iovec){ .iov_base = buf3, .iov_len = 128 };
    ssize_t readv_length = readv(fd, iovecs, 3);
    if (readv_length &lt; 0) {
        // readv error
        exit(1);
    }
    close(fd);
    return 0;
}
</code></pre>
<h3 id="实现-5"><a class="header" href="#实现-5">实现</a></h3>
<p>这三者实现的核心为<code>call_read_iter</code>函数，位于<code>include/linux/fs.h</code>文件中：</p>
<pre><code class="language-c">static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)
{
	return file-&gt;f_op-&gt;read_iter(kio, iter);
}
</code></pre>
<p>就像之前讲的一样，“怎么读”是由文件类型本身决定的，这里就是<code>file-&gt;f_op-&gt;read_iter</code>这个函数指针。</p>
<p>而其余结构则与<code>read</code>和<code>pread</code>的实现类似。</p>
<p>同时，可以指出，之前<code>read</code>和<code>pread</code>的实现中，第二个条件分支</p>
<pre><code class="language-c">if (file-&gt;f_op-&gt;read_iter)
		return new_sync_read(file, buf, count, pos);
</code></pre>
<p>就是防止文件类型只实现了<code>read_iter</code>而没有实现<code>iter</code>，因此用长度为1的数组调用<code>file-&gt;f_op-&gt;read_iter</code>。</p>
<h1 id="write-pwrite64-writev-pwritev-pwritev2系统调用"><a class="header" href="#write-pwrite64-writev-pwritev-pwritev2系统调用"><code>write</code>, <code>pwrite64</code>, <code>writev</code>, <code>pwritev</code>, <code>pwritev2</code>系统调用</a></h1>
<h2 id="write与pwrite64"><a class="header" href="#write与pwrite64"><code>write</code>与<code>pwrite64</code></a></h2>
<h3 id="系统调用号-6"><a class="header" href="#系统调用号-6">系统调用号</a></h3>
<p><code>write</code>的系统调用号为1，<code>pwrite64</code>的系统调用号为18。</p>
<h3 id="函数原型-5"><a class="header" href="#函数原型-5">函数原型</a></h3>
<h4 id="内核接口-6"><a class="header" href="#内核接口-6">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);
asmlinkage long sys_pwrite64(unsigned int fd, const char __user *buf, size_t count, loff_t pos);
</code></pre>
<h4 id="glibc封装-6"><a class="header" href="#glibc封装-6">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;unistd.h&gt;
ssize_t write(int fd, const void *buf, size_t count);
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
</code></pre>
<h3 id="简介-6"><a class="header" href="#简介-6">简介</a></h3>
<p><code>write</code>和<code>pwrite</code>是最基础的对文件写入的系统调用。<code>write</code>会将<code>buf</code>中<code>count</code>个字节写入描述符为<code>fd</code>的文件中，而<code>pread</code>则会将<code>buf</code>中<code>count</code>个字节写入描述符为<code>fd</code>的文件从<code>offset</code>开始的位置中。如果写入成功，这两个系统调用都将返回写入的字节数。因此，这两个系统调用主要的区别就在于写入的位置，其它功能均类似。</p>
<p>注意点：</p>
<p>首先，是文件偏移的问题：</p>
<ul>
<li>
<p>写入前位置</p>
<p>显然，<code>pwrite</code>是从文件偏移为<code>offset</code>的位置开始写入，但是<code>write</code>的问题则比较特殊。一般来说，<code>write</code>开始写入时的文件偏移就是当前的文件偏移，但是，当文件描述符是通过<code>open</code>系统调用创建，且创建时使用了<code>O_APPEND</code>标志位的话，每次<code>write</code>开始写入前，都会默认将文件偏移移到文件末尾。</p>
</li>
<li>
<p>写入后位置</p>
<p>同<code>read</code>和<code>pread</code>类似，<code>write</code>在成功写入n个字节后，会将文件偏移更新n个字节；但<code>pwrite</code>则不会更新文件偏移，因此和<code>pread</code>一起常用于多线程的代码中。</p>
</li>
</ul>
<p>我们可以通过<a href="https://github.com/Evian-Zhang/introduction-to-linux-x86_64-syscall/tree/master/codes/write-pwrite">一个简单的程序</a>检测这个性质</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

void test_file_offset(int fd) {
    char read_buf[16];
    char write_buf[] = &quot;payload&quot;;
    printf(&quot;File offset is %zd.\n&quot;, lseek(fd, 0, SEEK_CUR));
    ssize_t read_length = read(fd, read_buf, 4);
    read_buf[read_length] = '\0';
    printf(&quot;Read %zd bytes: %s.\n&quot;, read_length, read_buf);
    printf(&quot;File offset is %zd.\n&quot;, lseek(fd, 0, SEEK_CUR));
    printf(&quot;Write %zd bytes.\n&quot;, write(fd, write_buf, 7));
    printf(&quot;File offset is %zd.\n&quot;, lseek(fd, 0, SEEK_CUR));
    read_length = read(fd, read_buf, 4);
    read_buf[read_length] = '\0';
    printf(&quot;Read %zd bytes: %s.\n&quot;, read_length, read_buf);
    printf(&quot;File offset is %zd.\n&quot;, lseek(fd, 0, SEEK_CUR));
}

int main() {
    int fd_with_append = open(&quot;./text.txt&quot;, O_RDWR | O_APPEND);
    printf(&quot;File opened with O_APPEND:\n&quot;);
    test_file_offset(fd_with_append);
    close(fd_with_append);
    int fd_without_append = open(&quot;./text.txt&quot;, O_RDWR);
    printf(&quot;File opened without O_APPEND:\n&quot;);
    test_file_offset(fd_without_append);
    close(fd_without_append);
    return 0;
}
</code></pre>
<p>输出为</p>
<pre><code class="language-plaintext">File opened with O_APPEND:
File offset is 0.
Read 4 bytes: 1234.
File offset is 4.
Write 7 bytes.
File offset is 13.
Read 0 bytes: .
File offset is 13.
File opened without O_APPEND:
File offset is 0.
Read 4 bytes: 1234.
File offset is 4.
Write 7 bytes.
File offset is 11.
Read 2 bytes: ad.
File offset is 13.
</code></pre>
<p>我们在同目录中有一个文本文件<code>text.txt</code>，它的内容为六字节长的字符串&quot;123456&quot;。</p>
<ul>
<li>首先，我们使用<code>O_APPEND</code>标志位创建文件描述符<code>fd_with_append</code>。
<ol>
<li>使用<code>read</code>读入4字节。在读入前文件偏移为0，读入成功4字节，文件偏移为4，且读入的字符串为&quot;1234&quot;。</li>
<li>使用<code>write</code>写入7字节长度字符串&quot;payload&quot;。在写入前，文件偏移被移至文件末尾6，因此成功写入7字节后，文件偏移为13。</li>
<li>使用<code>read</code>读入4字节。在读入前，文件偏移为13，处于文件末尾，无内容读入，所以读入字节为0，读入后文件偏移依然为13。</li>
<li>最终，<code>text.txt</code>的内容为&quot;123456payload&quot;。</li>
</ol>
</li>
<li>接着，我们不使用<code>O_APPEND</code>标志位创建文件描述符<code>fd_without_append</code>。
<ol>
<li>使用<code>read</code>读入4字节。在读入前文件偏移为0，读入成功4字节，文件偏移为4，且读入的字符串为&quot;1234&quot;。</li>
<li>使用<code>write</code>写入7字节长度字符串&quot;payload&quot;。写入前文件偏移为4，写入成功7字节，文件偏移为11。此时<code>text.txt</code>的内容为&quot;1234payloadad&quot;。</li>
<li>使用<code>read</code>读入4字节。在读入前，文件偏移为11，文件总长度为13字节，所以只能读入成功2字节，读入后文件偏移为13，读入的字符串为&quot;ad&quot;。</li>
<li>最终，<code>text.txt</code>的内容为&quot;1234payload&quot;。</li>
</ol>
</li>
</ul>
<p>根据我们这个例子，很好地解释了文件偏移与<code>read</code>, <code>write</code>的关系。此外，还有一些需要注意的：</p>
<p>第一，在不使用<code>O_APPEND</code>标志位创建文件的例子中，为什么写入后文件的内容为<code>1234payloadad</code>。在写入前，由于上一轮的修改，文件的内容为&quot;123456payload&quot;。此时文件偏移为4，接下来将从&quot;56...&quot;的位置开始写入。而<code>write</code>如果写入的位置之后还有数据，是直接覆盖的，因此覆盖了7个字节，就变成了&quot;1234payloadad&quot;。这在<a href="https://pubs.opengroup.org/onlinepubs/9699919799/">POSIX标准</a>中有提及：</p>
<blockquote>
<p>After a <code>write()</code> to a regular file has successfully returned:</p>
<ul>
<li>Any subsequent successful <code>write()</code> to the same byte position in the file shall overwrite that file data.</li>
</ul>
</blockquote>
<p>第二，和<code>read</code>类似，<code>write</code>和<code>pwrite</code>返回的成功写入的字节数，可能会小于传入的参数<code>count</code>。这可能是由多种原因引起，比如说此硬盘分区的容量已满，或者超过了当前文件系统允许的单个文件的最大体积，此时，只能尽可能多地写入字节。比如说此硬盘分区还有2K字节就满了，我们企图写入5K字节，那么只能写入成功2K字节，所以<code>write</code>将返回2K。</p>
<p>但是，尽管如此，<code>write</code>和<code>pwrite</code>并不能保证在成功返回后，数据一定已经被写入硬盘。在某些情况下，甚至写入的错误也并不一定立刻出现。因此当我们再一次调用文件修改的操作，如<code>write</code>, <code>fsync</code>, <code>close</code>等时，就有可能出现错误。我们可以通过在写入数据后调用<code>fsync</code>，或是在<code>open</code>创建文件时使用<code>O_SYNC</code>或<code>O_DSYNC</code>标志位来解决这一问题。</p>
<p>虽然不能保证数据一定写入硬盘，POSIX标准同样规定了一件事：</p>
<blockquote>
<p>After a <code>write()</code> to a regular file has successfully returned:</p>
<ul>
<li>Any successful <code>read()</code> from each byte position in the file that was modified by that write shall return the data specified by the <code>write()</code> for that position until such byte positions are again modified.</li>
</ul>
</blockquote>
<p>也就是说，即使不保证写入硬盘，<code>read</code>读入的数据一定是<code>write</code>成功之后的数据。</p>
<h3 id="实现-6"><a class="header" href="#实现-6">实现</a></h3>
<p><code>write</code>和<code>pwrite</code>的实现均位于<code>fs/read_write.c</code>中，其核心为<code>__vfs_write</code>函数：</p>
<pre><code class="language-c">static ssize_t __vfs_write(struct file *file, const char __user *p, size_t count, loff_t *pos)
{
	if (file-&gt;f_op-&gt;write)
		return file-&gt;f_op-&gt;write(file, p, count, pos);
	else if (file-&gt;f_op-&gt;write_iter)
		return new_sync_write(file, p, count, pos);
	else
		return -EINVAL;
}
</code></pre>
<p>和<code>read</code>与<code>pread</code>类似，<code>write</code>和<code>pwrite</code>将调用文件类型对应的<code>write</code>函数指针，如果不存在，则调用其用于<code>writev</code>, <code>pwritev</code>的<code>write_iter</code>函数指针。</p>
<p>TODO: 对于常用的EXT4文件系统，找到『当文件描述符创建时使用<code>O_APPEND</code>标志位时，<code>write</code>系统调用会从文件末尾开始写入』这个特性的实现。</p>
<h2 id="writev-pwritev与pwritev2"><a class="header" href="#writev-pwritev与pwritev2"><code>writev</code>, <code>pwritev</code>与<code>pwritev2</code></a></h2>
<h3 id="系统调用号-7"><a class="header" href="#系统调用号-7">系统调用号</a></h3>
<p><code>writev</code>为20，<code>pwritev</code>为296，<code>pwritev2</code>为328。</p>
<h3 id="函数原型-6"><a class="header" href="#函数原型-6">函数原型</a></h3>
<h4 id="内核接口-7"><a class="header" href="#内核接口-7">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen);
asmlinkage long sys_pwritev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
asmlinkage long sys_pwritev2(unsigned long fd, const struct iovec __user *vec, unsigned long vlen, unsigned long pos_l, unsigned long pos_h, rwf_t flags);
</code></pre>
<h4 id="glibc封装-7"><a class="header" href="#glibc封装-7">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;sys/uio.h&gt;
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt, off_t offset);
ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt, off_t offset, int flags);
</code></pre>
<h3 id="简介-7"><a class="header" href="#简介-7">简介</a></h3>
<p>和<code>readv</code>, <code>preadv</code>, <code>preadv2</code>类似，这三个系统调用是为了解决一次性从多个连续内存向一个文件描述符写入的问题，这三个系统调用被称为“聚合写”（gather output）。</p>
<p>这三个系统调用的特性与<code>readv</code>, <code>preadv</code>, <code>preadv2</code>十分类似，这里不再赘述。</p>
<h1 id="lseek系统调用"><a class="header" href="#lseek系统调用"><code>lseek</code>系统调用</a></h1>
<h2 id="系统调用号-8"><a class="header" href="#系统调用号-8">系统调用号</a></h2>
<p>8</p>
<h2 id="函数签名-1"><a class="header" href="#函数签名-1">函数签名</a></h2>
<h3 id="内核接口-8"><a class="header" href="#内核接口-8">内核接口</a></h3>
<pre><code class="language-c">asmlinkage long sys_lseek(unsigned int fd, off_t offset, unsigned int whence);
</code></pre>
<h3 id="glibc封装-8"><a class="header" href="#glibc封装-8">glibc封装</a></h3>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
off_t lseek(int fd, off_t offset, int whence);
</code></pre>
<h2 id="简介-8"><a class="header" href="#简介-8">简介</a></h2>
<p>对于支持seek的文件类型，在内核的文件描述中，会有一个“文件偏移”（file offset）。这个的作用是标记后续的<code>read</code>和<code>write</code>的起点。而<code>lseek</code>系统调用的作用就是操作这个文件偏移。</p>
<p>对于<code>fd</code>对应的文件，<code>lseek</code>的功能根据<code>whence</code>的不同而不同。<code>whence</code>可能的值包括：</p>
<ul>
<li>
<p><code>SEEK_SET</code></p>
<p>将文件偏移置于<code>offset</code></p>
</li>
<li>
<p><code>SEEK_CUR</code></p>
<p>将文件偏移置于距当前偏移的<code>offset</code>字节。</p>
<p><code>offset</code>为正则为当前偏移之后，<code>offset</code>为负则为当前偏移之前</p>
</li>
<li>
<p><code>SEEK_END</code></p>
<p>将文件偏移置于距文件末尾的<code>offset</code>字节。</p>
<p><code>offset</code>为负则为文件末尾之前。<code>offset</code>可以为正，表示在文件末尾之后的<code>offset</code>个字节。如果在此处写入，那么使用<code>read</code>读取之前文件末尾至当前偏移，将会得到被<code>\0</code>填充的区域（被称为洞）。</p>
<p>假设当前文件长度为5字节，我们使用<code>lseek</code>，从第8字节的位置开始写入。然后使用<code>read</code>读取6到7字节的内容，则内容为<code>\0</code>填充的2字节区域。</p>
</li>
<li>
<p><code>SEEK_DATA</code></p>
<p>将文件偏移置于从<code>offset</code>开始，第一个包含数据的字节。</p>
<p>如果我们使用<code>SEEK_END</code>制造了洞，且当前文件偏移在洞中，则<code>SEEK_DATA</code>将会将我们的文件偏移移动到之后第一个有数据的区域。</p>
</li>
<li>
<p><code>SEEK_HOLE</code></p>
<p>将文件偏移置于从<code>offset</code>开始，第一个洞的开始字节。</p>
<p>如果该文件没有洞，则将置于文件末尾。</p>
</li>
</ul>
<p><code>lseek</code>的返回值为进行修改文件偏移的操作之后，当前的文件偏移。</p>
<p>我们可以用<a href="https://github.com/Evian-Zhang/introduction-to-linux-x86_64-syscall/tree/master/codes/lseek-hole">这个示例</a>来简单了解一下<code>lseek</code>的功能：</p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int fd = open(&quot;./text.txt&quot;, O_RDWR);
    int end_offset = lseek(fd, 0, SEEK_END);
    lseek(fd, 4, SEEK_END);
    write(fd, &quot;123&quot;, 3);
    char buf[4];
    lseek(fd, end_offset, SEEK_SET);
    read(fd, buf, 4);
    for (int i = 0; i &lt; 4; i++) {
        printf(&quot;%d&quot;, buf[i]);
    }
    printf(&quot;\n&quot;);

    int at_hole = lseek(fd, end_offset + 2, SEEK_SET);
    int next_data = lseek(fd, at_hole, SEEK_DATA);
    printf(&quot;Current offset %d at hole, move to %d with SEEK_DATA\n&quot;, at_hole, next_data);

    int at_data = lseek(fd, end_offset - 2, SEEK_SET);
    int next_hole = lseek(fd, at_data, SEEK_HOLE);
    printf(&quot;Current offset %d at data, move to %d with SEEK_HOLE\n&quot;, at_data, next_hole);

    return 0;
}
</code></pre>
<p>其中<code>text.txt</code>的内容长度为6字节。</p>
<p>因此，我们的步骤是</p>
<ol>
<li>将文件偏移移动到末尾之后4字节，当前文件偏移为10</li>
<li>写入数据</li>
<li>将文件偏移移动到6</li>
<li>读入4字节数据。这4字节由于在“洞“中，所以均为0</li>
<li>将文件偏移移动到8</li>
<li>使用<code>SEEK_DATA</code>找到下一个有数据的区域，文件偏移为10</li>
<li>将文件偏移移动到4</li>
<li>使用<code>SEEK_HOLE</code>找到下一个洞的区域，文件偏移为6</li>
</ol>
<p>但是，由于不同的文件系统对<code>SEEK_DATA</code>和<code>SEEK_HOLE</code>的支持不同，上述行为在不同文件系统下可能会不同。最简单的实现就是，<code>SEEK_DATA</code>不改变文件偏移，<code>SEEK_HOLE</code>移动到文件末尾，也就是把“洞”也看作正常的数据。</p>
<h2 id="实现-7"><a class="header" href="#实现-7">实现</a></h2>
<p><code>lseek</code>的实现位于<code>fs/read_write.c</code>，其最终调用的是<code>vfs_llseek</code>：</p>
<pre><code class="language-c">loff_t vfs_llseek(struct file *file, loff_t offset, int whence)
{
	loff_t (*fn)(struct file *, loff_t, int);

	fn = no_llseek;
	if (file-&gt;f_mode &amp; FMODE_LSEEK) {
		if (file-&gt;f_op-&gt;llseek)
			fn = file-&gt;f_op-&gt;llseek;
	}
	return fn(file, offset, whence);
}
</code></pre>
<p>而我们来看看比较常见的EXT4文件系统的实现，其位于<code>fs/ext4/file.c</code>:</p>
<pre><code class="language-c">loff_t ext4_llseek(struct file *file, loff_t offset, int whence)
{
	struct inode *inode = file-&gt;f_mapping-&gt;host;
	loff_t maxbytes;

	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))
		maxbytes = EXT4_SB(inode-&gt;i_sb)-&gt;s_bitmap_maxbytes;
	else
		maxbytes = inode-&gt;i_sb-&gt;s_maxbytes;

	switch (whence) {
	default:
		return generic_file_llseek_size(file, offset, whence,
						maxbytes, i_size_read(inode));
	case SEEK_HOLE:
		inode_lock_shared(inode);
		offset = iomap_seek_hole(inode, offset, &amp;ext4_iomap_ops);
		inode_unlock_shared(inode);
		break;
	case SEEK_DATA:
		inode_lock_shared(inode);
		offset = iomap_seek_data(inode, offset, &amp;ext4_iomap_ops);
		inode_unlock_shared(inode);
		break;
	}

	if (offset &lt; 0)
		return offset;
	return vfs_setpos(file, offset, maxbytes);
}
</code></pre>
<p>对于<code>SEEK_HOLE</code>和<code>SEEK_DATA</code>，EXT4特殊考虑了，实现了正确的行为。对于一般的操作，则是使用<code>fs/read_write</code>里的<code>generic_file_llseek_size</code>函数：</p>
<pre><code class="language-c">loff_t
generic_file_llseek_size(struct file *file, loff_t offset, int whence,
		loff_t maxsize, loff_t eof)
{
	switch (whence) {
	case SEEK_END:
		offset += eof;
		break;
	case SEEK_CUR:
		/*
		 * Here we special-case the lseek(fd, 0, SEEK_CUR)
		 * position-querying operation.  Avoid rewriting the &quot;same&quot;
		 * f_pos value back to the file because a concurrent read(),
		 * write() or lseek() might have altered it
		 */
		if (offset == 0)
			return file-&gt;f_pos;
		/*
		 * f_lock protects against read/modify/write race with other
		 * SEEK_CURs. Note that parallel writes and reads behave
		 * like SEEK_SET.
		 */
		spin_lock(&amp;file-&gt;f_lock);
		offset = vfs_setpos(file, file-&gt;f_pos + offset, maxsize);
		spin_unlock(&amp;file-&gt;f_lock);
		return offset;
	case SEEK_DATA:
		/*
		 * In the generic case the entire file is data, so as long as
		 * offset isn't at the end of the file then the offset is data.
		 */
		if ((unsigned long long)offset &gt;= eof)
			return -ENXIO;
		break;
	case SEEK_HOLE:
		/*
		 * There is a virtual hole at the end of the file, so as long as
		 * offset isn't i_size or larger, return i_size.
		 */
		if ((unsigned long long)offset &gt;= eof)
			return -ENXIO;
		offset = eof;
		break;
	}

	return vfs_setpos(file, offset, maxsize);
}
</code></pre>
<p>这是默认实现的行为，对于<code>SEEK_SET</code>, <code>SEEK_CUR</code>和<code>SEEK_END</code>，清楚地实现了它们的功能；对于<code>SEEK_DATA</code>，则默认不改变文件偏移，<code>SEEK_HOLE</code>则会移动到文件末尾。</p>
<h1 id="poll-select-pselect6-ppoll系统调用"><a class="header" href="#poll-select-pselect6-ppoll系统调用"><code>poll</code>, <code>select</code>, <code>pselect6</code>, <code>ppoll</code>系统调用</a></h1>
<h2 id="select与poll"><a class="header" href="#select与poll"><code>select</code>与<code>poll</code></a></h2>
<h3 id="系统调用号-9"><a class="header" href="#系统调用号-9">系统调用号</a></h3>
<p><code>poll</code>为7，<code>select</code>为23。</p>
<h3 id="函数原型-7"><a class="header" href="#函数原型-7">函数原型</a></h3>
<h4 id="内核接口-9"><a class="header" href="#内核接口-9">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);
asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timeval __user *tvp);
</code></pre>
<h4 id="glibc封装-9"><a class="header" href="#glibc封装-9">glibc封装</a></h4>
<p><code>poll</code></p>
<pre><code class="language-c">#include &lt;poll.h&gt;
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre>
<p><code>select</code></p>
<pre><code class="language-c">#include &lt;sys/select.h&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<h3 id="简介-9"><a class="header" href="#简介-9">简介</a></h3>
<p><code>select</code>与<code>poll</code>都是为了实现IO多路复用的功能。</p>
<p>一般来说，对硬盘上的文件的读取都不会阻塞。但是，对管道、套接字、伪终端等文件的读取，是可能产生阻塞的。举个例子来说，如果我们读取<code>stdin</code>：</p>
<pre><code class="language-c">int fd = STDIN_FILENO; // stdin
char buf[64];
read(fd, buf, 64); // blocks here
process_read_content(buf);
</code></pre>
<p>那么，在执行<code>read</code>时，如果我们一直不向终端输入，那么这里会始终阻塞着，程序永远不会执行到之后的<code>process_read_context(buf)</code>。在这种情况下，这种行为是符合逻辑的，因为我们之后的语句是依赖读入的内容<code>buf</code>的。所以除非我们收到了<code>buf</code>的内容，否则就不应该执行之后的指令。</p>
<p>但是，如果有多个文件需要读入，就产生了问题。假设我们有一个<code>nfd</code>个元素的文件描述符数组<code>fds</code>，我们需要对他们读入，并彼此独立地分别处理每个读入的内容。</p>
<ul>
<li>
<p>方案一</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    for (int i = 0; i &lt; nfd; i++) {
        char buf[64];
        read(fds[i], buf, 64);
        process_read_content(buf);
    }
}
</code></pre>
<p>这个方案能完成我们的需求，但是效率实在是太低了。由于是按顺序依次处理读入的内容，如果<code>fds[0]</code>始终没有输入，但是<code>fds[1]</code>早就有了输入。我们明明可以先处理<code>fds[1]</code>的输入的，但是由于进程阻塞在了<code>fds[0]</code>的<code>read</code>操作中，我们的时间就这样被白白浪费了。</p>
</li>
<li>
<p>方案二</p>
<p>既然每个文件描述符处理读入是互相独立的，我们就可以创建<code>nfd</code>个线程，每个线程中处理其读入。</p>
<p>这种方案确实可以解决我们方案一中的问题，但是线程的创建、线程之间的切换是非常耗费时间的。</p>
</li>
</ul>
<p>为了更高效地解决这个问题，我们可以增加一个新的操作——判断某个文件描述符是否可以读入。我们可以遍历文件描述符，判断是否有已经可以读入的，如果有的话就直接处理，如果没有的话就再次遍历。这样几乎没有耗费的时间。</p>
<p>我们甚至可以想出更高效的方案，在主线程中查询是否有可以读取的文件描述符，然后把可以读取的文件描述符给别的线程执行。</p>
<p><code>select</code>就为我们提供了一个类似的解决方案。我们给<code>select</code>传入需要检测IO状态（可以读入、可以写入等）的文件描述符集合，<code>select</code>立即返回，告诉我们哪些文件描述符的IO已经准备就绪。</p>
<p><code>poll</code>的功能和<code>select</code>类似，但解决了一些<code>select</code>的缺点。具体请见下面的用法一节。</p>
<h3 id="用法-2"><a class="header" href="#用法-2">用法</a></h3>
<h4 id="select"><a class="header" href="#select"><code>select</code></a></h4>
<p><code>select</code>的函数签名为</p>
<pre><code class="language-c">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<p><code>readfds</code>, <code>writefds</code>和<code>exceptfds</code>是文件描述符集合，分别用于：</p>
<ul>
<li>
<p><code>readfds</code></p>
<p>已经准备好供读取的文件描述符集合，即<code>read</code>操作不会阻塞。</p>
</li>
<li>
<p><code>writefds</code></p>
<p>已经准备好供写入的文件描述符集合，即<code>write</code>操作不会阻塞。</p>
</li>
<li>
<p><code>exceptfds</code></p>
<p>其余条件的文件描述符集合。包括：</p>
<ul>
<li>TCP套接字有带外数据</li>
<li>处于包模式下的伪终端的主端检测到从端的状态变化</li>
<li><code>cgroup.events</code>文件被修改</li>
</ul>
</li>
</ul>
<p>如果对相应的状态变化不感兴趣，在对应的参数中传递<code>NULL</code>即可。</p>
<p>我们可以用以下几个函数操作<code>fd_set</code>类型的变量：</p>
<pre><code class="language-c">void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
</code></pre>
<ul>
<li>
<p><code>FD_ZERO</code></p>
<p>将<code>set</code>清空</p>
</li>
<li>
<p><code>FD_SET</code></p>
<p>将<code>fd</code>放入<code>set</code>中</p>
</li>
<li>
<p><code>FD_CLR</code></p>
<p>将<code>fd</code>从<code>set</code>中移除</p>
</li>
<li>
<p><code>FD_ISSET</code></p>
<p>判断<code>fd</code>是否处于<code>set</code>中</p>
</li>
</ul>
<p><code>nfds</code>为<code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>中，数值最大的文件描述符加1。如<code>readfds</code>包含文件描述符4, 6, 7，<code>writefds</code>包含文件描述符5，<code>exceptfds</code>为空，则<code>nfds</code>为8。</p>
<p><code>timeout</code>为超时参数，其结构为</p>
<pre><code class="language-c">struct timeval {
    time_t      tv_sec;         /* seconds */
    suseconds_t tv_usec;        /* microseconds */
};
</code></pre>
<p>如果<code>timeout</code>指针为<code>NULL</code>，则<code>select</code>将一直等待，直到有一个文件描述符准备好。如果<code>tv_sec</code>和<code>tv_usec</code>均为0，则<code>select</code>将立即返回。否则，<code>select</code>如果等待达到<code>timeout</code>的时间，还没有任何文件描述符准备好，就返回。</p>
<p>当函数返回之后，会有如下变化：</p>
<ul>
<li>返回值为<code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>中准备好的文件描述符的总数</li>
<li><code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>中会只保留已经处于准备好状态的文件描述符。我们可以通过<code>FD_ISSET</code>去查看哪些文件描述符准备好。（正因如此，如果我们在一个循环中使用<code>select</code>，那在每次使用之前，需要复制一遍各集合，或用<code>FD_CLR</code>清空后重新添加）</li>
<li><code>select</code>可能会更新<code>timeout</code>参数。</li>
</ul>
<p>综上，如果我们要用<code>select</code>，按第三个方案来实现我们的功能，其写法为</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    fd_set rset;
    FD_ZERO(&amp;rset);
    int maxfd = -1;
    for (int i = 0; i &lt; nfd; i++) {
        FD_SET(fds[i], &amp;rset);
        if (fds[i] &gt; maxfd) {
            maxfd = fds[i];
        }
    }
    while (1) {
        fd_set tmp_rset;
        memcpy(&amp;tmp_rset, &amp;rset, sizeof(fd_set));
        if (select(maxfd + 1, &amp;tmp_rset, NULL, NULL, NULL) &lt;= 0) {
            break;
        }
        for (int i = 0; i &lt; nfd; i++) {
            if (FD_ISSET(fds[i], &amp;tmp_rset)) {
                FD_CLR(fds[i], &amp;rset);
                char buf[64];
                read(fds[i], buf, 64);
                process_read_content(buf);
            }
        }
    }
}
</code></pre>
<p>此外，值得注意的是，glibc的封装要求我们的文件描述符的值不能超过<code>FD_SETSIZE</code>，也就是1024。</p>
<h4 id="poll"><a class="header" href="#poll"><code>poll</code></a></h4>
<p><code>poll</code>的函数签名为</p>
<pre><code class="language-c">int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre>
<p>与<code>select</code>不同的是，它并不是把文件描述符放在<code>fd_set</code>结构体中，而是放在一个<code>struct pollfd</code>类型组成的数组中，<code>nfds</code>为该数组的长度。</p>
<p><code>struct pollfd</code>的定义为</p>
<pre><code class="language-c">struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};
</code></pre>
<p><code>fd</code>是文件描述符，<code>events</code>是用户感兴趣的事件（类似于<code>select</code>中的<code>readfds</code>, <code>writefds</code>和<code>exceptfds</code>），由用户填写；<code>revents</code>是实际发生的事件，由内核填写。</p>
<p><code>events</code>与<code>revents</code>是位掩码，其可以包含的标志位有</p>
<ul>
<li>
<p><code>POLLIN</code>：存在数据可以读入（相当于<code>select</code>中的<code>readfds</code>）</p>
</li>
<li>
<p><code>POLLPRI</code>：存在其他条件满足（相当于<code>select</code>中的<code>exceptfds</code>）</p>
</li>
<li>
<p><code>POLLOUT</code>：存在数据可以写入（相当于<code>select</code>中的<code>writefds</code>）</p>
</li>
<li>
<p><code>POLLRDHUP</code></p>
<p>流套接字对端关闭连接。</p>
<p>需定义<code>_GNU_SOURCE</code>宏。</p>
</li>
<li>
<p><code>POLLERR</code></p>
<p>出错。</p>
<p>只可由<code>revents</code>包含，不可由<code>events</code>包含</p>
</li>
<li>
<p><code>POLLHUP</code></p>
<p>挂起。</p>
<p>只可由<code>revents</code>包含，不可由<code>events</code>包含</p>
</li>
<li>
<p><code>POLLNVAL</code></p>
<p>由于<code>fd</code>未打开，请求无效。</p>
<p>只可由<code>revents</code>包含，不可由<code>events</code>包含</p>
</li>
</ul>
<p>当<code>events</code>为0时，<code>revents</code>只可返回<code>POLLERR</code>, <code>POLLHUP</code>和<code>POLLNVAL</code>（将<code>events</code>置为0类似于<code>select</code>中的<code>FD_CLR</code>）。若其不为0，则可以返回<code>events</code>中包含的事件，以及<code>POLLERR</code>, <code>POLLHUP</code>和<code>POLLNVAL</code>。如果返回的<code>revents</code>为0，则表示什么都没发生，可能超时了，或者别的文件描述符中发生了用户感兴趣的事。</p>
<p><code>timeout</code>参数表示其最多等待时间（以毫秒为单位）。如果其为负，则表示<code>poll</code>无限等待；如果其为0，则表示<code>poll</code>立即返回。</p>
<p>如果在超时范围内，任何一个用户感兴趣的事件发生了，<code>poll</code>将会返回，返回值为产生用户感兴趣事件的文件描述符个数；如果超时了，没有任何一个用户感兴趣的事件发生，则<code>poll</code>将会返回0。</p>
<p>综上，如果我们要用<code>poll</code>，按第三个方案来实现我们的功能，其写法为</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    struct pollfd *pollfds = (struct pollfd *)malloc(nfd * sizeof(struct pollfd));
    for (int i = 0; i &lt; nfd; i++) {
        pollfds[i].fd = fds[i];
        pollfds[i].events = POLLIN;
    }
    while (1) {
        if (poll(pollfds, nfd, -1) &lt;= 0) {
            break;
        }
        for (int i = 0; i &lt; nfd; i++) {
            if (pollfds[i].revents &amp; POLLIN) {
                pollfds[i].events = 0;
                char buf[64];
                read(fds[i], buf, 64);
                process_read_content(buf);
            }
        }
    }
}
</code></pre>
<p>与<code>select</code>不同的是，其可以包含的文件描述符个数无上限。</p>
<p>根据上述的讨论，<code>poll</code>与<code>select</code>的区别在于</p>
<ul>
<li><code>poll</code>文件描述符个数无上限，<code>select</code>文件描述符其值上限为<code>FD_SETSIZE</code></li>
<li><code>poll</code>感兴趣的事件种类更多</li>
<li><code>poll</code>不需要在每次调用前都复制一遍<code>fd_set</code>，也就是<code>poll</code>不会改变传入的<code>fds</code>。</li>
<li><code>poll</code>超时参数精度为毫秒，<code>select</code>超时参数精度为微秒，<code>select</code>更精确。</li>
</ul>
<h3 id="实现-8"><a class="header" href="#实现-8">实现</a></h3>
<h4 id="select-1"><a class="header" href="#select-1"><code>select</code></a></h4>
<p>首先我们来看看<code>fd_set</code>与和其相关的函数是怎么实现的。在Linux内核的<code>include/linux/types.h</code>中可以看到</p>
<pre><code class="language-c">typedef __kernel_fd_set		fd_set;
</code></pre>
<p>而在<code>include/uapi/linux/posix_types.h</code>中可以看到</p>
<pre><code class="language-c">#define __FD_SETSIZE	1024

typedef struct {
	unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
} __kernel_fd_set;
</code></pre>
<p>所以，这其实就是一个长度为1024字节的位数组。同时我们也明白了，为什么<code>select</code>要求文件描述符的值不能超过<code>FD_SETSIZE</code>。</p>
<p>同时，我们也可以在glibc的源码<code>misc/sys/select.h</code>中看到和其相关的函数的定义</p>
<pre><code class="language-c">#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)
</code></pre>
<p>其实现则位于<code>bits/select.h</code>：</p>
<pre><code class="language-c">#define __FD_ZERO(s) \
  do {									      \
    unsigned int __i;							      \
    fd_set *__arr = (s);						      \
    for (__i = 0; __i &lt; sizeof (fd_set) / sizeof (__fd_mask); ++__i)	      \
      __FDS_BITS (__arr)[__i] = 0;					      \
  } while (0)
#define __FD_SET(d, s) \
  ((void) (__FDS_BITS (s)[__FD_ELT(d)] |= __FD_MASK(d)))
#define __FD_CLR(d, s) \
  ((void) (__FDS_BITS (s)[__FD_ELT(d)] &amp;= ~__FD_MASK(d)))
#define __FD_ISSET(d, s) \
  ((__FDS_BITS (s)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)
</code></pre>
<p>简单来说，就是：</p>
<ul>
<li><code>FD_ZERO</code>将整个位数组清0（不用<code>memset</code>的原因是，这可能需要在之前声明<code>memset</code>的原型，并且这个数组其实并不大）</li>
<li><code>FD_SET</code>将该文件描述符对应的比特位置1</li>
<li><code>FD_CLR</code>将该文件描述符对应的比特位置0</li>
<li><code>FD_ISSET</code>判断该文件描述符对应的比特位是否为1</li>
</ul>
<p>接着，我们来看看<code>select</code>内部的实现。其实现均位于Linux内核源码的<code>fs/select.c</code>文件中。</p>
<p>首先，在<code>core_sys_select</code>函数里，使用了一个<code>fd_set_bits</code>的结构体，其定义为：</p>
<pre><code class="language-c">typedef struct {
	unsigned long *in, *out, *ex;
	unsigned long *res_in, *res_out, *res_ex;
} fd_set_bits;
</code></pre>
<p>一共六个位数组，前三个是存储我们传入的参数的，后三个存储结果，在最终再复制进前三个中。</p>
<p><code>select</code>的实现，最主要的就是<code>do_select</code>函数，其内容非常长，但也十分重要：</p>
<pre><code class="language-c">static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)
{
	ktime_t expire, *to = NULL;
	struct poll_wqueues table;
	poll_table *wait;
	int retval, i, timed_out = 0;
	u64 slack = 0;
	__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
	unsigned long busy_start = 0;

	rcu_read_lock();
	retval = max_select_fd(n, fds);
	rcu_read_unlock();

	if (retval &lt; 0)
		return retval;
	n = retval;

	poll_initwait(&amp;table);
	wait = &amp;table.pt;
	if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) {
		wait-&gt;_qproc = NULL;
		timed_out = 1;
	}

	if (end_time &amp;&amp; !timed_out)
		slack = select_estimate_accuracy(end_time);

	retval = 0;
	for (;;) {
		unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;
		bool can_busy_loop = false;

		inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;
		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;

		for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) {
			unsigned long in, out, ex, all_bits, bit = 1, j;
			unsigned long res_in = 0, res_out = 0, res_ex = 0;
			__poll_t mask;

			in = *inp++; out = *outp++; ex = *exp++;
			all_bits = in | out | ex;
			if (all_bits == 0) {
				i += BITS_PER_LONG;
				continue;
			}

			for (j = 0; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= 1) {
				struct fd f;
				if (i &gt;= n)
					break;
				if (!(bit &amp; all_bits))
					continue;
				f = fdget(i);
				if (f.file) {
					wait_key_set(wait, in, out, bit,
						     busy_flag);
					mask = vfs_poll(f.file, wait);

					fdput(f);
					if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {
						res_in |= bit;
						retval++;
						wait-&gt;_qproc = NULL;
					}
					if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {
						res_out |= bit;
						retval++;
						wait-&gt;_qproc = NULL;
					}
					if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {
						res_ex |= bit;
						retval++;
						wait-&gt;_qproc = NULL;
					}
					/* got something, stop busy polling */
					if (retval) {
						can_busy_loop = false;
						busy_flag = 0;

					/*
					 * only remember a returned
					 * POLL_BUSY_LOOP if we asked for it
					 */
					} else if (busy_flag &amp; mask)
						can_busy_loop = true;

				}
			}
			if (res_in)
				*rinp = res_in;
			if (res_out)
				*routp = res_out;
			if (res_ex)
				*rexp = res_ex;
			cond_resched();
		}
		wait-&gt;_qproc = NULL;
		if (retval || timed_out || signal_pending(current))
			break;
		if (table.error) {
			retval = table.error;
			break;
		}

		/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */
		if (can_busy_loop &amp;&amp; !need_resched()) {
			if (!busy_start) {
				busy_start = busy_loop_current_time();
				continue;
			}
			if (!busy_loop_timeout(busy_start))
				continue;
		}
		busy_flag = 0;

		/*
		 * If this is the first loop and we have a timeout
		 * given, then we convert to ktime_t and set the to
		 * pointer to the expiry value.
		 */
		if (end_time &amp;&amp; !to) {
			expire = timespec64_to_ktime(*end_time);
			to = &amp;expire;
		}

		if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,
					   to, slack))
			timed_out = 1;
	}

	poll_freewait(&amp;table);

	return retval;
}
</code></pre>
<p><code>fd_set_bits</code>类型的<code>fds</code>，其表示输入的字段复制于系统调用的输入，其表示输出的字段在调用前被清空。</p>
<p>其主体部分为两层嵌套的循环。在最外层循环中，每一轮循环处理<code>BITS_PER_LONG</code>，也就是一般来说64个文件描述符。这是因为我们的数据是用<code>long</code>的位数组来存储的，所以这样分批次效率更高。在内循环中，我们遍历这个<code>long</code>整型的每个字节，其每个字节对应一个文件描述符。</p>
<p>也就是说，我们从0开始，一直到我们传入系统调用的参数<code>n</code>，也就是最大的文件描述符的值，遍历每个文件描述符，在在53行看到，通过<code>bit &amp; all_bits</code>，判断当前的文件描述符是否在我们之前传入的<code>in</code>, <code>out</code>或<code>ex</code>集合中。对于存在集合中的，最终调用了<code>vfs_poll</code>来查询单个文件的状态，其实现位于<code>fs/poll.h</code>中：</p>
<pre><code class="language-c">static inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt)
{
	if (unlikely(!file-&gt;f_op-&gt;poll))
		return DEFAULT_POLLMASK;
	return file-&gt;f_op-&gt;poll(file, pt);
}
</code></pre>
<p>依旧是函数指针模拟多态。</p>
<p>最终，再把<code>res_in</code>, <code>res_out</code>, <code>res_ex</code>复制回原本的<code>in</code>, <code>out</code>, <code>ex</code>即可。</p>
<p>总的来说，<code>select</code>的步骤是，对于输入的参数<code>nfds</code>，把值从0到<code>nfds - 1</code>的所有相关的文件描述符都查询一遍，对于每个文件描述符，调用<code>vfs_poll</code>查询状态。</p>
<h4 id="poll-1"><a class="header" href="#poll-1"><code>poll</code></a></h4>
<p><code>poll</code>的实现位于<code>fs/select.c</code>，其核心<code>do_poll</code>依然很长，但也十分重要：</p>
<pre><code class="language-c">static int do_poll(struct poll_list *list, struct poll_wqueues *wait, struct timespec64 *end_time)
{
	poll_table* pt = &amp;wait-&gt;pt;
	ktime_t expire, *to = NULL;
	int timed_out = 0, count = 0;
	u64 slack = 0;
	__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
	unsigned long busy_start = 0;

	/* Optimise the no-wait case */
	if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) {
		pt-&gt;_qproc = NULL;
		timed_out = 1;
	}

	if (end_time &amp;&amp; !timed_out)
		slack = select_estimate_accuracy(end_time);

	for (;;) {
		struct poll_list *walk;
		bool can_busy_loop = false;

		for (walk = list; walk != NULL; walk = walk-&gt;next) {
			struct pollfd * pfd, * pfd_end;

			pfd = walk-&gt;entries;
			pfd_end = pfd + walk-&gt;len;
			for (; pfd != pfd_end; pfd++) {
				/*
				 * Fish for events. If we found one, record it
				 * and kill poll_table-&gt;_qproc, so we don't
				 * needlessly register any other waiters after
				 * this. They'll get immediately deregistered
				 * when we break out and return.
				 */
				if (do_pollfd(pfd, pt, &amp;can_busy_loop,
					      busy_flag)) {
					count++;
					pt-&gt;_qproc = NULL;
					/* found something, stop busy polling */
					busy_flag = 0;
					can_busy_loop = false;
				}
			}
		}
		/*
		 * All waiters have already been registered, so don't provide
		 * a poll_table-&gt;_qproc to them on the next loop iteration.
		 */
		pt-&gt;_qproc = NULL;
		if (!count) {
			count = wait-&gt;error;
			if (signal_pending(current))
				count = -ERESTARTNOHAND;
		}
		if (count || timed_out)
			break;

		/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */
		if (can_busy_loop &amp;&amp; !need_resched()) {
			if (!busy_start) {
				busy_start = busy_loop_current_time();
				continue;
			}
			if (!busy_loop_timeout(busy_start))
				continue;
		}
		busy_flag = 0;

		/*
		 * If this is the first loop and we have a timeout
		 * given, then we convert to ktime_t and set the to
		 * pointer to the expiry value.
		 */
		if (end_time &amp;&amp; !to) {
			expire = timespec64_to_ktime(*end_time);
			to = &amp;expire;
		}

		if (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))
			timed_out = 1;
	}
	return count;
}
</code></pre>
<p>传入的参数<code>list</code>的类型是<code>struct poll_list</code>的指针：</p>
<pre><code class="language-c">struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};
</code></pre>
<p>也就是说，这里是一个链表。其<code>entries</code>字段是一个变长数组。我们传入<code>do_poll</code>的<code>list</code>参数是将传入系统调用的<code>fds</code>，也就是由<code>nfds</code>个<code>struct pollfd</code>类型的实例组成的数组，在之前的<code>do_sys_poll</code>函数中，被分成长度为<code>POLLFD_PER_PAGE</code>的若干个部分，然后再将每个部分用链表串联起来。这样做的原因应该就是保证每次处理的一批不会超过页大小，尽量减少换页。</p>
<p>在<code>do_poll</code>函数中我们可以看到，对每个链表项，遍历了其<code>entries</code>数组，也就相当于对我们传入的<code>fds</code>进行遍历。对每一个文件描述符，使用<code>do_pollfd(pfd, pt, &amp;can_busy_loop, busy_flag)</code>来进行真正的<code>poll</code>操作，而<code>do_pollfd</code>，实际上就是调用的<code>vfs_poll</code>。</p>
<h2 id="pselect6与ppoll"><a class="header" href="#pselect6与ppoll"><code>pselect6</code>与<code>ppoll</code></a></h2>
<h3 id="系统调用号-10"><a class="header" href="#系统调用号-10">系统调用号</a></h3>
<p><code>pselect6</code>为270，<code>ppoll</code>为271。</p>
<h3 id="函数签名-2"><a class="header" href="#函数签名-2">函数签名</a></h3>
<h4 id="内核接口-10"><a class="header" href="#内核接口-10">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct __kernel_timespec __user *, void __user *);
asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int, struct __kernel_timespec __user *, const sigset_t __user *, size_t);
</code></pre>
<h4 id="glibc封装-10"><a class="header" href="#glibc封装-10">glibc封装</a></h4>
<p><code>pselect6</code></p>
<pre><code class="language-c">#include &lt;sys/select.h&gt;
int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout,  const sigset_t *sigmask);
</code></pre>
<p><code>ppoll</code></p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;signal.h&gt;
#include &lt;poll.h&gt;
int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask);
</code></pre>
<h3 id="简介-10"><a class="header" href="#简介-10">简介</a></h3>
<p><code>pselect</code>与<code>select</code>的区别主要在于：</p>
<ul>
<li>超时精度
<ul>
<li><code>select</code>使用的是<code>struct timeval</code>结构体，精确到微秒</li>
<li><code>pselect</code>使用的是<code>struct timespec</code>结构体，精确到纳秒</li>
</ul>
</li>
<li>超时参数
<ul>
<li><code>select</code>可能会更新其超时参数<code>timeout</code></li>
<li><code>pselect6</code>系统调用可能会更新其超时参数，glibc的封装<code>pselect</code>不会更新其超时参数</li>
</ul>
</li>
<li>信号掩码
<ul>
<li><code>pselect</code>可以设置信号掩码，若其为<code>NULL</code>，则行为与<code>select</code>相同</li>
</ul>
</li>
</ul>
<p><code>ppoll</code>与<code>poll</code>的区别主要在于：</p>
<ul>
<li>超时精度
<ul>
<li><code>poll</code>使用的超时精度为毫秒</li>
<li><code>ppoll</code>使用的是<code>struct timespec</code>结构体，精确到纳秒</li>
</ul>
</li>
<li>信号掩码
<ul>
<li><code>ppoll</code>可以设置信号掩码，若其为<code>NULL</code>，则行为与<code>poll</code>相同</li>
</ul>
</li>
</ul>
<p><code>pselect</code>与<code>ppoll</code>可以看作执行<code>select</code>或<code>poll</code>前后设置信号掩码。之所以需要这两个单独的系统调用，是因为如果我们的需求是，要么接收到特定的信号，要么某个文件描述符准备好，然后执行后续的操作。如果我们分为两步操作，但是接受信号实际上是在判断是否接收到信号之后，也就是判断结果为没接收到信号，而且在调用<code>select</code>之前，那么就可能陷入无限等待。<code>pselect</code>与<code>ppoll</code>进行信号判断的时候则是使用原子操作，所以不会产生这样的竞争条件。</p>
<h3 id="实现-9"><a class="header" href="#实现-9">实现</a></h3>
<p><code>pselect6</code>与<code>ppoll</code>在Linux内核中的实现与<code>select</code>和<code>poll</code>类似。有一点需要说明的是，<code>pselect6</code>接受的最后一个参数是<code>void *</code>类型的，这是因为它实际上需要的类型为</p>
<pre><code class="language-c">struct {
    const kernel_sigset_t *ss;   /* Pointer to signal set */
    size_t ss_len;               /* Size (in bytes) of object
                                    pointed to by 'ss' */
};
</code></pre>
<p>本来其实可以把这两个字段变成两个函数的参数的，但由于Linux x86_64的ABI要求系统调用至多只能接受6个参数，所以最后一个参数只能是这样的结构体了。</p>
<p>值得注意的是，在glibc的封装中，以<code>pselect</code>为例：</p>
<p>我们在glibc源码的<code>sysdeps/unix/sysv/linux/pselect.c</code>中可以看到：</p>
<pre><code class="language-c">int
__pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	   const struct timespec *timeout, const sigset_t *sigmask)
{
  /* The Linux kernel can in some situations update the timeout value.
     We do not want that so use a local variable.  */
  struct timespec tval;
  if (timeout != NULL)
    {
      tval = *timeout;
      timeout = &amp;tval;
    }

  /* Note: the system call expects 7 values but on most architectures
     we can only pass in 6 directly.  If there is an architecture with
     support for more parameters a new version of this file needs to
     be created.  */
  struct
  {
    __syscall_ulong_t ss;
    __syscall_ulong_t ss_len;
  } data;

  data.ss = (__syscall_ulong_t) (uintptr_t) sigmask;
  data.ss_len = _NSIG / 8;

  return SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds,
                         timeout, &amp;data);
}
</code></pre>
<p>通过设置一个局部变量<code>tval</code>，使得传入的参数<code>timeout</code>不会被内核修改。<code>ppoll</code>也进行了类似的操作。</p>
<h1 id="epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1系统调用"><a class="header" href="#epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1系统调用"><code>epoll_create</code>, <code>epoll_wait</code>, <code>epoll_ctl</code>, <code>epoll_pwait</code>, <code>epoll_create1</code>系统调用</a></h1>
<h2 id="系统调用号-11"><a class="header" href="#系统调用号-11">系统调用号</a></h2>
<ul>
<li><code>epoll_create</code>: 213</li>
<li><code>epoll_wait</code>: 232</li>
<li><code>epoll_ctl</code>: 233</li>
<li><code>epoll_pwait</code>: 281</li>
<li><code>epoll_create1</code>: 291</li>
</ul>
<h2 id="函数原型-8"><a class="header" href="#函数原型-8">函数原型</a></h2>
<h3 id="内核接口-11"><a class="header" href="#内核接口-11">内核接口</a></h3>
<pre><code class="language-c">asmlinkage long sys_epoll_create(int size);
asmlinkage long sys_epoll_wait(int epfd, struct epoll_event __user *events, int maxevents, int timeout);
asmlinkage long sys_epoll_ctl(int epfd, int op, int fd, struct epoll_event __user *event);
asmlinkage long sys_epoll_pwait(int epfd, struct epoll_event __user *events, int maxevents, int timeout, const sigset_t __user *sigmask, size_t sigsetsize);
asmlinkage long sys_epoll_create1(int flags);
</code></pre>
<h3 id="glibc封装-11"><a class="header" href="#glibc封装-11">glibc封装</a></h3>
<pre><code class="language-c">#include &lt;sys/epoll.h&gt;
int epoll_create(int size);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask);
int epoll_create1(int flags);
</code></pre>
<h2 id="简介-11"><a class="header" href="#简介-11">简介</a></h2>
<p>与<a href="src/filesystem/./poll-select-pselect6-ppoll.html"><code>select</code>和<code>poll</code></a>一样，epoll机制也是为了实现IO多路复用。其使用方法更先进，内部实现也更高效。</p>
<p>我们可以理解为，Linux内核为了实现epoll机制，在内核空间维护了一个数据结构，称为epoll实例。其包含两个集合，一个是由用户感兴趣的文件描述符与相应的事件组成，另一个是由触发了相应事件的文件描述符与相应的事件组成。</p>
<p>我们的整体步骤是</p>
<ol>
<li>创建一个epoll实例</li>
<li>对于epoll实例，将我们感兴趣的文件描述符与相应的事件添加到集合中</li>
<li>从触发事件的集合中提取相应的文件描述符</li>
</ol>
<h2 id="使用"><a class="header" href="#使用">使用</a></h2>
<h3 id="epoll_create与epoll_create1"><a class="header" href="#epoll_create与epoll_create1"><code>epoll_create</code>与<code>epoll_create1</code></a></h3>
<p>其函数签名为</p>
<pre><code class="language-c">int epoll_create(int size);
int epoll_create1(int flags);
</code></pre>
<p>这两个系统调用就是在内核空间创建一个epoll实例，返回该实例的文件描述符。</p>
<p>对于<code>epoll_create</code>，<code>size</code>参数是被忽略的，但其必须大于0。</p>
<p><code>epoll_create1</code>是<code>epoll_create</code>的加强版。如果<code>flags</code>为0，则其行为与<code>epoll_create</code>一致。此外，<code>flags</code>还可以加入<code>EPOLL_CLOEXEC</code>标志位，和<code>open</code>中的<code>O_CLOEXEC</code>标志位功能一致，具体请看<a href="src/filesystem/./open-openat-name_to_handle_at-open_by_handle_at-open_tree.html">相应的描述</a>。</p>
<p>由<code>epoll_create</code>和<code>epoll_create1</code>创建的文件描述符，也就是epoll实例对应的文件描述符也应在程序结束前使用<code>close</code>关闭。但我们应当注意，正如<a href="src/filesystem/./open-openat-name_to_handle_at-open_by_handle_at-open_tree.html">在<code>open</code>中描述的</a>，如果使用了<code>dup</code>或者<code>fork</code>等会复制文件描述符的操作，我们将会有多个文件描述符指向Linux内核空间中的epoll实例。只有所有的指向该epoll实例的文件描述符都被关闭，其内核空间中的资源才会被释放。</p>
<h3 id="epoll_ctl"><a class="header" href="#epoll_ctl"><code>epoll_ctl</code></a></h3>
<p>其函数签名为</p>
<pre><code class="language-c">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre>
<p>其可以看作epoll机制中较为核心的系统调用。</p>
<p>总的来说，该系统调用接受的四个参数的意义为：</p>
<ul>
<li>
<p><code>epfd</code></p>
<p>epoll实例的文件描述符</p>
</li>
<li>
<p><code>op</code></p>
<p>希望进行的操作</p>
</li>
<li>
<p><code>fd</code></p>
<p>感兴趣的文件描述符</p>
</li>
<li>
<p><code>events</code></p>
<p>对应于该文件描述符，感兴趣的事件</p>
</li>
</ul>
<p>首先，<code>epfd</code>的意义很简单，就是我们调用<code>epoll_create</code>或<code>epoll_create1</code>返回的epoll实例的文件描述符。</p>
<p><code>op</code>是我们希望进行的操作，包括：</p>
<ul>
<li>
<p><code>EPOLL_CTL_ADD</code></p>
<p>向epoll实例的用户感兴趣的集合中增添元素，文件描述符由<code>fd</code>给出，感兴趣的事件由<code>event</code>给出</p>
</li>
<li>
<p><code>EPOLL_CTL_MOD</code></p>
<p>修改epoll实例的用户感兴趣的集合中的元素。希望修改的元素的文件描述符由<code>fd</code>给出，修改后的事件由<code>event</code>给出</p>
</li>
<li>
<p><code>EPOLL_CTL_DEL</code></p>
<p>删除epoll实例的用户感兴趣的集合中的元素。希望删除的元素的文件描述符由<code>fd</code>给出，<code>event</code>变量将被忽略，可以为<code>NULL</code></p>
</li>
</ul>
<p>而<code>fd</code>和<code>events</code>就是这个系统调用的核心参数。</p>
<p><code>fd</code>可以<strong>看作</strong>在<b><code>epoll_ctl</code>阶段</b>，在epoll实例中，用于区分用户感兴趣的集合中的不同元素的方法。这是因为，我们的增加、修改、删除操作，都是基于<code>fd</code>来选择相应的元素的。</p>
<p>这里有一点需要我们考虑。我们考虑以下情况：</p>
<p>我们通过<code>dup</code>、<code>fork</code>等复制文件描述符的操作，创造了<code>fd1</code>和<code>fd2</code>这两个文件描述符，但是其都指向同一个文件描述。如果我们将<code>fd1</code>和<code>fd2</code>都加入epoll实例的用户感兴趣的集合，同时其对应的用户感兴趣的事件是不同的。然后，我们使用<code>close</code>关闭<code>fd1</code>。但由于文件描述没有被释放，在我们使用<code>epoll_wait</code>获取触发了的事件时，仍然会有<code>fd1</code>对应的事件报告出来。</p>
<p>因此，只有指向同一文件描述的所有文件描述符都被关闭，在epoll实例的用户感兴趣的集合中才会删除所有相应的元素。所以，我们在使用<code>close</code>关闭某个被加入epoll实例的文件描述符之前，记得要使用<code>EPOLL_CTL_DEL</code>操作先删除相应的元素。</p>
<p><code>event</code>参数的类型是<code>struct epoll_event</code>的指针。结合我们之后将到的<code>epoll_wait</code>，这个参数的作用是标记相应的事件。当我们把这个参数传递给<code>epoll_ctl</code>时，这个参数表明我们关心的事件。随后我们使用<code>epoll_wait</code>同样会获得这个类型的实例，其表明触发的事件。</p>
<p><code>struct epoll_event</code>的定义为</p>
<pre><code class="language-c">struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
</code></pre>
<p>首先来讲讲<code>data</code>字段。<code>epoll_data_t</code>的定义为</p>
<pre><code class="language-c">typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;
</code></pre>
<p>这个字段对epoll实例来说并不会起到实际的用途。当我们把<code>data</code>作为一个字段，放在某个用户感兴趣的<code>epoll_event</code>事件中，传入<code>epoll_ctl</code>函数，那么内核就会记录这个<code>data</code>。当相应的事件触发之后，用户使用<code>epoll_wait</code>等获得相应的事件，此时<code>data</code>会不经修改地出现在返回的事件中。</p>
<p>这个<code>data</code>常见的用途是，由于<code>epoll_wait</code>等方法获得事件时，无法直接获得该事件对应的文件描述符，所以我们在使用<code>epoll_ctl</code>时，将文件描述符作为<code>data</code>即可。随后在<code>epoll_wait</code>获得的事件中，取其<code>data</code>字段，获得相应的<code>fd</code>。</p>
<p>而<code>events</code>字段是epoll的核心。<code>events</code>字段是一个位掩码，其主要包含以下几种标志位：</p>
<ul>
<li>
<p><code>EPOLLET</code></p>
<p>epoll处理的事件有两种模式：边沿触发（edge-triggered）与水平触发（level-triggered）。</p>
<p>考虑以下情形：</p>
<ol>
<li>我们向<code>epoll</code>实例注册一个文件描述符<code>rfd</code>，其代表某个管道的读端。我们关心其是否已经可读</li>
<li>从写端往管道里写了2KB数据</li>
<li>我们使用<code>epoll_wait</code>获得触发了的事件，其中包括我们事先注册的<code>rfd</code></li>
<li>我们从<code>rfd</code>读取了1KB数据</li>
<li>我们再次使用<code>epoll_wait</code></li>
</ol>
<p>如果是边沿触发模式，那么epoll只会在第3步的<code>epoll_wait</code>中给出<code>rfd</code>被触发的事件，第5步则不会给出相应的事件；如果是水平触发，那么epoll在第3步和第5步都会给出相应的事件。</p>
<p>也就是说，只有在相应的文件描述符<strong>状态发生变化</strong>，从别的状态变成我们感兴趣的状态时，“边沿触发”才会给出我们相应的事件；只要相应的文件描述符<strong>处于感兴趣的状态</strong>时，“水平触发”就会给出我们相应的事件。</p>
<p>因此，当我们使用边沿触发模式时，我们的<code>read</code>或<code>write</code>操作不能只使用一次，因为之后相关的事件就不会被触发，也就不能读取或写入完整的数据了。我们应当在循环中使用<code>read</code>或<code>write</code>，直到其返回错误<code>EAGAIN</code>（详见<a href="src/filesystem/./open-openat-name_to_handle_at-open_by_handle_at-open_tree.html">open</a>）。同时由于<code>EAGAIN</code>错误只有在使用<code>O_NONBLOCK</code>标志位打开文件时才会出现，所以我们在使用边沿触发时要注意两点：</p>
<ul>
<li>使用非阻塞的文件描述符</li>
<li><code>read</code>和<code>write</code>要一直读取或写入到返回<code>EAGAIN</code>错误</li>
</ul>
<p>如果我们的<code>events</code>包含标志位<code>EPOLLET</code>，则该事件是边沿触发模式；如果不包含该标志位，则该事件是水平触发模式。</p>
<p>该标志位只可包含在传递给<code>epoll_ctl</code>的<code>events</code>中，不会出现在<code>epoll_wait</code>等返回的<code>events</code>中。</p>
</li>
<li>
<p><code>EPOLLIN</code></p>
<p>文件描述符已经可以被读取</p>
</li>
<li>
<p><code>EPOLLOUT</code></p>
<p>文件描述符已经可以被写入</p>
</li>
<li>
<p><code>EPOLLRDHUP</code></p>
<p>流套接字的对端关闭连接</p>
</li>
<li>
<p><code>EPOLLPRI</code></p>
<p><code>select</code>中的其他条件，<code>poll</code>中的<code>POLLPRI</code></p>
</li>
<li>
<p><code>EPOLLERR</code></p>
<p>出现错误。</p>
<p>该标志位可能出现在<code>epoll_wait</code>等返回的<code>events</code>中，epoll默认关注这样的状态，因此并没有必要包含在传递给<code>epoll_ctl</code>的<code>events</code>中</p>
</li>
<li>
<p><code>EPOLLHUP</code></p>
<p>相关的文件描述符处于挂起状态。</p>
<p>该标志位可能出现在<code>epoll_wait</code>等返回的<code>events</code>中，epoll默认关注这样的状态，因此并没有必要包含在传递给<code>epoll_ctl</code>的<code>events</code>中</p>
</li>
<li>
<p><code>EPOLLONESHOT</code></p>
<p>如果包含该标志位，该事件被触发，被<code>epoll_wait</code>等返回，那么该事件对应的文件描述符将不再会有别的事件被epoll实例关注。也就是说，如果该文件描述符别的事件出现了，epoll实例并不会返回相应的结果。</p>
<p>如果要再次接受相应的事件，就应在<code>epoll_ctl</code>中使用<code>EPOLL_CTL_MOD</code>，给该事件新的事件掩码。</p>
<p>在一个多线程程序中，如果我们在一个循环中调用epoll，每次获得一个触发的事件，就开启一个新的线程去处理，那么有可能某个状态没有改变，但是导致某个事件被多次触发，从而使得我们有多个线程去处理同一个文件描述符的状态。因此我们可以使用<code>EPOLLONESHOT</code>标志位来避免这种事。</p>
<p>该标志位只可包含在传递给<code>epoll_ctl</code>的<code>events</code>中，不会出现在<code>epoll_wait</code>等返回的<code>events</code>中。</p>
</li>
</ul>
<h3 id="epoll_wait与epoll_pwait"><a class="header" href="#epoll_wait与epoll_pwait"><code>epoll_wait</code>与<code>epoll_pwait</code></a></h3>
<p>这两个系统调用的函数签名为</p>
<pre><code class="language-c">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask);
</code></pre>
<p><code>epoll_wait</code>与<code>epoll_pwait</code>就是从epoll实例的准备好的集合中，获取相应的事件。其参数包括：</p>
<ul>
<li><code>epfd</code>为epoll实例的文件描述符。</li>
<li><code>events</code>为一个数组，其元素类型为<code>struct epoll_event</code>，长度为<code>maxevents</code>。</li>
<li><code>timeout</code>为超时参数。</li>
</ul>
<p>对于<code>events</code>参数，epoll实例会从准备好的集合中，选取至多<code>maxevents</code>个事件放入该数组中。</p>
<p>对于<code>timeout</code>参数，其精度为毫秒，如果其为-1，则<code>epoll_wait</code>将无限等待；如果其为0，则<code>epoll_wait</code>将立即返回。</p>
<p><code>epoll_wait</code>的返回值为准备好的文件描述符的个数。</p>
<p>与<code>pselect</code>和<code>ppoll</code>类似，<code>epoll_pwait</code>就是加上了信号掩码的<code>epoll_wait</code>。</p>
<p>因此，如果使用epoll来实现我们在<a href="src/filesystem/./poll-select-pselect6-ppoll.html"><code>select</code>与<code>poll</code></a>中提出的方案三，其方法为：</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    int epfd = epoll_create1(0);
    for (int i = 0; i &lt; nfd; i++) {
        struct epoll_event ev;
        ev.events = EPOLLIN;
        ev.data.fd = fds[i];
        epoll_ctl(epfd, EPOLL_CTL_ADD, fds[i], &amp;ev);
    }
    struct epoll_event *events = (struct epoll_event *)malloc(nfd * sizeof(struct epoll_event));
    while (1) {
        int ready_nfd = epoll_wait(epfd, events, nfd, -1);
        if (ready_nfd &lt;= 0) {
            break;
        }
        for (int i = 0; i &lt; ready_nfd; i++) {
            if (events[i].events &amp; EPOLLIN) {
                char buf[64];
                read(events[i].data.fd, buf, 64);
                process_read_content(buf);
            }
        }
    }
}
</code></pre>
<h2 id="实现-10"><a class="header" href="#实现-10">实现</a></h2>
<p>epoll的实现位于Linux内核的<code>fs/eventpoll.c</code>文件中。</p>
<p>在epoll的实现中，有两个结构体最为关键：<code>struct eventpoll</code>与<code>struct epitem</code>。</p>
<p><code>struct eventpoll</code>就是内核中的epoll实例的结构体，而<code>struct epitem</code>就是一个文件描述符与它相关的事件组成的结构体，也就是epoll实例的两个集合的元素。</p>
<p>它们的<strong>部分</strong>字段如下：</p>
<p><code>struct eventpoll</code>:</p>
<pre><code class="language-c">struct eventpoll {
	/* Wait queue used by sys_epoll_wait() */
	wait_queue_head_t wq;

	/* Wait queue used by file-&gt;poll() */
	wait_queue_head_t poll_wait;

	/* List of ready file descriptors */
	struct list_head rdllist;

	/* RB tree root used to store monitored fd structs */
	struct rb_root_cached rbr;

	/*
	 * This is a single linked list that chains all the &quot;struct epitem&quot; that
	 * happened while transferring ready events to userspace w/out
	 * holding -&gt;lock.
	 */
	struct epitem *ovflist;

	/* wakeup_source used when ep_scan_ready_list is running */
	struct wakeup_source *ws;

	struct list_head visited_list_link;
};
</code></pre>
<p><code>struct epitem</code>:</p>
<pre><code class="language-c">struct epitem {
	union {
		/* RB tree node links this structure to the eventpoll RB tree */
		struct rb_node rbn;
		/* Used to free the struct epitem */
		struct rcu_head rcu;
	};

	/* List header used to link this structure to the eventpoll ready list */
	struct list_head rdllink;

	/*
	 * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the
	 * single linked chain of items.
	 */
	struct epitem *next;

	/* The file descriptor information this item refers to */
	struct epoll_filefd ffd;

	/* Number of active wait queue attached to poll operations */
	int nwait;

	/* List containing poll wait queues */
	struct list_head pwqlist;

	/* The &quot;container&quot; of this item */
	struct eventpoll *ep;

	/* List header used to link this item to the &quot;struct file&quot; items list */
	struct list_head fllink;

	/* wakeup_source used when EPOLLWAKEUP is set */
	struct wakeup_source __rcu *ws;

	/* The structure that describe the interested events and the source fd */
	struct epoll_event event;
};
</code></pre>
<p>首先是<code>struct rb_root_cached rbr</code>这个字段。这就是epoll实例中用于存储用户感兴趣的事件的结构。它是一个红黑树，其包含的元素可以看作我们的<code>struct epitem</code>（其字段<code>rbn</code>就是表示在这棵红黑树的节点）。当我们使用<code>epoll_create</code>创建一个epoll实例时，这棵红黑树被初始化。当我们使用<code>epoll_ctl</code>去操作感兴趣的集合时，我们实际上就是增添、修改、删除这棵红黑树的元素。</p>
<p>这里值得注意的是，我们之前提到，在<code>epoll_ctl</code>阶段，可以把文件描述符<strong>看作</strong>集合的键，在我们操作这个集合的时候，通过这个键来区分不同的元素。但实际并不是这样。</p>
<p>以这棵红黑树的插入为例，其实现为<code>ep_rbtree_insert</code>:</p>
<pre><code class="language-c">static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &amp;ep-&gt;rbr.rb_root.rb_node, *parent = NULL;
	struct epitem *epic;
	bool leftmost = true;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&amp;epi-&gt;ffd, &amp;epic-&gt;ffd);
		if (kcmp &gt; 0) {
			p = &amp;parent-&gt;rb_right;
			leftmost = false;
		} else
			p = &amp;parent-&gt;rb_left;
	}
	rb_link_node(&amp;epi-&gt;rbn, parent, p);
	rb_insert_color_cached(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr, leftmost);
}
</code></pre>
<p>可以看到在11行，通过调用<code>ep_cmp_ffd</code>来判断是否两个元素相同。首先我们来看看<code>struct epitem</code>的<code>ffd</code>字段，其类型为<code>struct epoll_filefd</code>:</p>
<pre><code class="language-c">struct epoll_filefd {
	struct file *file;
	int fd;
} __packed;
</code></pre>
<p>而<code>ep_cmp_ffd</code>的实现为</p>
<pre><code class="language-c">static inline int ep_cmp_ffd(struct epoll_filefd *p1, struct epoll_filefd *p2)
{
	return (p1-&gt;file &gt; p2-&gt;file ? +1:
	        (p1-&gt;file &lt; p2-&gt;file ? -1 : p1-&gt;fd - p2-&gt;fd));
}
</code></pre>
<p>因此我们可以看到，内核是同时使用文件描述与文件描述符作为这棵红黑树的键的。</p>
<p>如果我们想通过<code>epoll_ctl</code>增加一个我们感兴趣的元素，我们做的核心实际上是增加了一个回调函数。首先我们需要知道，在<code>include/linux/poll.h</code>中，我们对某个文件的<code>poll</code>操作，其最终是这样的情形：</p>
<pre><code class="language-c">/* 
 * structures and helpers for f_op-&gt;poll implementations
 */
typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

/*
 * Do not touch the structure directly, use the access functions
 * poll_does_not_wait() and poll_requested_events() instead.
 */
typedef struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
} poll_table;

static inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt)
{
	if (unlikely(!file-&gt;f_op-&gt;poll))
		return DEFAULT_POLLMASK;
	return file-&gt;f_op-&gt;poll(file, pt);
}
</code></pre>
<p>我们使用<code>vfs_poll</code>之后，会把<code>file</code>和<code>pt</code>传入其对应的实现中。而<code>pt</code>是<code>struct poll_table_struct</code>的指针，其中，<code>_key</code>字段是一个掩码，表明哪些事件是用户关注的；<code>poll_queue_proc _qproc</code>是一个函数指针。当出现了<code>_key</code>中的事件时，会自动触发这个回调函数。</p>
<p>当我们使用<code>epoll_ctl</code>去创建新的红黑树节点时，有一步为</p>
<pre><code class="language-c">/* Initialize the poll table using the queue callback */
epq.epi = epi;
init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);

/*
 * Attach the item to the poll hooks and get current event bits.
 * We can safely use the file* here because its usage count has
 * been increased by the caller of this function. Note that after
 * this operation completes, the poll callback can start hitting
 * the new item.
 */
revents = ep_item_poll(epi, &amp;epq.pt, 1);
</code></pre>
<p>这就是我们设置相应回调函数的地方。<code>epq</code>的类型是<code>struct ep_pqueue</code>，其定义为</p>
<pre><code class="language-c">struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};
</code></pre>
<p>也就是说把<code>poll_table</code>封装了一层。我们通过<code>init_poll_funcptr</code>设置了<code>epq</code>的<code>poll_table</code>，然后通过<code>ep_item_poll</code>把这个<code>poll_table</code>传入了最终的<code>vfs_poll</code>函数中。</p>
<p>在epoll中，<code>poll_table</code>的<code>_key</code>字段，也就是用户感兴趣的事件是全部事件，epoll会从触发的事件中筛选出用户感兴趣的事件。回调函数则是<code>ep_ptable_queue_proc</code>，其设置了回调函数<code>ep_poll_callback</code>。</p>
<p>TODO：增加更多的描述。参考资料：</p>
<ul>
<li><a href="https://idndx.com/the-implementation-of-epoll-1/">the-implementation-of-epoll-1</a></li>
<li><a href="https://idndx.com/the-implementation-of-epoll-2/">the-implementation-of-epoll-2</a></li>
<li><a href="https://idndx.com/the-implementation-of-epoll-3/">the-implementation-of-epoll-3</a></li>
<li><a href="https://idndx.com/the-implementation-of-epoll-4/">the-implementation-of-epoll-4</a></li>
</ul>
<h1 id="stat-fstat-lstat-newfstatat-statx系统调用"><a class="header" href="#stat-fstat-lstat-newfstatat-statx系统调用"><code>stat</code>, <code>fstat</code>, <code>lstat</code>, <code>newfstatat</code>, <code>statx</code>系统调用</a></h1>
<h2 id="stat-fstat-lstat与newfstatat"><a class="header" href="#stat-fstat-lstat与newfstatat"><code>stat</code>, <code>fstat</code>, <code>lstat</code>与<code>newfstatat</code></a></h2>
<h3 id="系统调用号-12"><a class="header" href="#系统调用号-12">系统调用号</a></h3>
<p><code>stat</code>为4，<code>fstat</code>为5，<code>lstat</code>为6，<code>newfstatat</code>为262。</p>
<h3 id="函数签名-3"><a class="header" href="#函数签名-3">函数签名</a></h3>
<h4 id="内核接口-12"><a class="header" href="#内核接口-12">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_newstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_newfstat(unsigned int fd, struct stat __user *statbuf);
asmlinkage long sys_newlstat(const char __user *filename, struct stat __user *statbuf);
asmlinkage long sys_newfstatat(int dfd, const char __user *filename, struct stat __user *statbuf, int flag);
</code></pre>
<h4 id="glibc封装-12"><a class="header" href="#glibc封装-12">glibc封装</a></h4>
<p><code>stat</code>, <code>fstat</code>, <code>lstat</code>:</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
</code></pre>
<p><code>newfstatat</code>:</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags);
</code></pre>
<h3 id="简介-12"><a class="header" href="#简介-12">简介</a></h3>
<p>这四个系统调用都和文件的状态信息有关，也就是和<code>struct stat</code>这个结构体密切相关。首先，我们来看看其定义（该结构体在不同的指令集、内核版本中都不尽相同，该结构体为当前Linux内核版本下的x86_64版本）：</p>
<pre><code class="language-c">struct stat {
    dev_t st_dev;
    ino_t st_ino;
    nlink_t st_nlink;
    mode_t st_mode;
    uid_t st_uid;
    gid_t st_gid;
    dev_t st_rdev;
    off_t st_size;
    blksize_t st_blksize;
    blkcnt_t st_blocks;
#ifdef __USE_XOPEN2K8
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
#define st_atime st_atim.tv_sec
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
#else
    time_t st_atime;
    unsigned long st_atimensec;
    time_t st_mtime;
    unsigned long st_mtimensec;
    time_t st_ctime;
    unsigned long st_ctimensec;
#endif
};
</code></pre>
<p>其中每个字段的含义如下：</p>
<ul>
<li>
<p><code>st_dev</code>: 包含该文件的设备ID</p>
</li>
<li>
<p><code>st_ino</code>: inode数</p>
</li>
<li>
<p><code>st_nlink</code>: 该文件的硬链接数</p>
</li>
<li>
<p><code>st_mode</code>: 文件类型和模式。</p>
<ul>
<li>
<p>文件类型</p>
<p>通过与位掩码<code>S_IFMT</code>相与可得到相应的文件类型：</p>
<ul>
<li><code>S_IFSOCK</code>: 套接字文件</li>
<li><code>S_IFLINK</code>: 符号链接</li>
<li><code>S_IFREG</code>: 常规文件</li>
<li><code>S_IFBLK</code>: 块设备</li>
<li><code>S_IFDIR</code>: 目录</li>
<li><code>S_IFCHR</code>: 字符设备</li>
<li><code>S_IFOFO</code>: FIFO（管道）</li>
</ul>
</li>
<li>
<p>文件模式</p>
<p>通过与下列掩码相与可以得到相应的数据：</p>
<ul>
<li>
<p>特殊权限</p>
<ul>
<li>
<p><code>S_ISUID</code>: SUID位</p>
<p>在大部分情况下，如果将一个可执行的二进制程序的该位设为1，则运行该二进制程序产生的进程的euid与该文件的uid相同。该进程拥有该文件属主的权限。</p>
</li>
<li>
<p><code>S_ISGID</code>: SGID位</p>
<p>在大部分情况下，如果将一个可执行的二进制程序的该位设为1，则运行该二进制程序产生的进程的egid与该文件的gid相同。该进程拥有该文件属组的权限。</p>
<p>如果将一个目录的该位设为1，则表明在其中创建的所有文件的gid均与该目录相同，而不与创建该文件的进程的gid相同。</p>
</li>
<li>
<p><code>S_ISVTX</code>: Sticky位</p>
<p>如果将一个目录的该位设为1，则该目录中所有文件只能被该文件的属主、该目录的属主以及特权进程重命名或删除。</p>
</li>
</ul>
</li>
<li>
<p>所有者权限</p>
<ul>
<li><code>S_IRWXU</code>: 属主拥有读、写、执行权限</li>
<li><code>S_IRUSR</code>: 属主拥有读权限</li>
<li><code>S_IWUSR</code>: 属主拥有写权限</li>
<li><code>S_IXUSR</code>: 属主拥有执行权限</li>
</ul>
</li>
<li>
<p>用户组权限</p>
<ul>
<li><code>S_IRWXG</code>: 属组拥有读、写、执行权限</li>
<li><code>S_IRGRP</code>: 属组拥有读权限</li>
<li><code>S_IWGRP</code>: 属组拥有写权限</li>
<li><code>S_IXGRP</code>: 属组拥有执行权限</li>
</ul>
</li>
<li>
<p>其它用户权限</p>
<ul>
<li><code>S_IRWXO</code>: 他人拥有读、写、执行权限</li>
<li><code>S_IROTH</code>: 他人拥有读权限</li>
<li><code>S_IWOTH</code>: 他人拥有写权限</li>
<li><code>S_IXOTH</code>: 他人拥有执行权限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>st_uid</code>: 该文件的uid</p>
</li>
<li>
<p><code>st_gid</code>: 该文件的gid</p>
</li>
<li>
<p><code>st_rdev</code>: 如果该文件表示一个设备，则为该文件所表示的设备ID</p>
</li>
<li>
<p><code>st_size</code>: 文件大小（以字节计）</p>
<p>如果该文件是一个符号链接，则表示其链接的源路径对应的字符串长度</p>
</li>
<li>
<p><code>st_blksize</code>: 使用高效文件IO时，推荐使用的块大小</p>
</li>
<li>
<p><code>st_blocks</code>: 分配给该文件的块数目（以512字节为一个单位）</p>
</li>
<li>
<p>时间戳</p>
<ul>
<li>
<p>首先，各个名称的意义：</p>
<ul>
<li><code>atime</code>: 最后访问时间</li>
<li><code>mtime</code>: 最后修改时间</li>
<li><code>ctime</code>: 文件状态最后修改时间</li>
<li><code>mtime</code>与<code>ctime</code>的区别在于，前者是文件内容的修改，而后者则是文件对应inode的修改。如只修改<code>st_atime</code>字段，而不修改文件内容，则<code>mtime</code>不变，<code>ctime</code>发生改变。</li>
</ul>
</li>
<li>
<p>如果：</p>
<ul>
<li><code>_POSIX_C_SOURCE</code>宏定义为不小于200809L的值</li>
<li><code>_XOPEN_SOURCE</code>定义为不小于700的值</li>
<li><code>_BSD_SOURCE</code>被定义</li>
<li><code>_SVID_SOURCE</code>被定义</li>
</ul>
<p>上述条件只需要满足任意一个，我们就可以通过<code>st_atime</code>或<code>st_atim.tv_sec</code>访问UNIX时间戳（以秒为单位），<code>st_atime.tv_nsec</code>访问其纳秒部分（不是总时长，而是除去秒部分，剩下的纳秒部分的大小）。其余几个时间也可以用类似的方式访问秒和纳秒部分。</p>
</li>
<li>
<p>如果上面的条件都不满足，我们则可以通过<code>st_atime</code>访问UNIX时间戳（以秒为单位），<code>st_atimensec</code>访问其纳秒部分。</p>
</li>
<li>
<p>也就是说，无论何种情况，我们都可以用<code>st_atime</code>访问以秒为单位的UNIX时间戳。</p>
</li>
</ul>
</li>
</ul>
<p><code>stat</code>是根据文件路径获得相应的文件状态信息，但如果文件是一个符号链接，则会获得其指向的实际文件的信息。</p>
<p><code>lstat</code>也是根据文件路径获得相应的文件信息，但如果文件是一个符号链接，则会获得链接本身的状态信息。</p>
<p><code>fstat</code>是根据文件描述符获得相应的文件信息，行为和<code>stat</code>相同。</p>
<p><code>fstatat</code>则是一个更普遍的接口，可以提供<code>stat</code>, <code>lstat</code>, <code>fstat</code>的功能。首先，<code>dirfd</code>与<code>pathname</code>的用法与<code>openat</code>相同，既可以用于绝对路径，也可以用于相对特定目录的相对路径，也可以用于相对当前目录的相对路径。其次，对于<code>flags</code>，其主要的标志位的功能有：</p>
<ul>
<li>如果包含<code>AT_EMPTY_PATH</code>标志位，且<code>filename</code>是空字符串，则获得<code>dirfd</code>句柄对应的文件的状态信息。此时<code>dirfd</code>可以是任何文件类型，而不一定是目录。这种行为类似<code>fstat</code>。</li>
<li>如果包含<code>AT_SYMLINK_NOFOLLOW</code>标志位，且<code>dirfd</code>和<code>filename</code>组成的路径是一个符号链接，则获得链接本身的状态信息（相当于<code>lstat</code>）；如果不包含该标志位，则获得链接指向的实际文件的信息（相当于<code>stat</code>）。</li>
</ul>
<h3 id="实现-11"><a class="header" href="#实现-11">实现</a></h3>
<p>这四个系统调用的实现均位于<code>fs/stat.c</code>中。其实现的核心为位于<code>fs/stat.c</code>中的<code>vfs_getattr_nosec</code>函数：</p>
<pre><code class="language-c">int vfs_getattr_nosec(const struct path *path, struct kstat *stat, u32 request_mask, unsigned int query_flags)
{
	struct inode *inode = d_backing_inode(path-&gt;dentry);

	memset(stat, 0, sizeof(*stat));
	stat-&gt;result_mask |= STATX_BASIC_STATS;
	request_mask &amp;= STATX_ALL;
	query_flags &amp;= KSTAT_QUERY_FLAGS;

	/* allow the fs to override these if it really wants to */
	if (IS_NOATIME(inode))
		stat-&gt;result_mask &amp;= ~STATX_ATIME;
	if (IS_AUTOMOUNT(inode))
		stat-&gt;attributes |= STATX_ATTR_AUTOMOUNT;

	if (inode-&gt;i_op-&gt;getattr)
		return inode-&gt;i_op-&gt;getattr(path, stat, request_mask,
					    query_flags);

	generic_fillattr(inode, stat);
	return 0;
}
</code></pre>
<p>我们可以看到，其最关键的就在于<code>inode-&gt;i_op-&gt;getattr</code>。因此，其和<code>read</code>, <code>write</code>类似，也是通过函数指针实现多态的方式，获得相应的状态。</p>
<h2 id="statx"><a class="header" href="#statx"><code>statx</code></a></h2>
<h3 id="系统调用号-13"><a class="header" href="#系统调用号-13">系统调用号</a></h3>
<p>332</p>
<h3 id="函数签名-4"><a class="header" href="#函数签名-4">函数签名</a></h3>
<h4 id="内核接口-13"><a class="header" href="#内核接口-13">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags, unsigned mask, struct statx __user *buffer);
</code></pre>
<h4 id="glibc封装-13"><a class="header" href="#glibc封装-13">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
int statx(int dirfd, const char *pathname, int flags, unsigned int mask, struct statx *statxbuf);
</code></pre>
<p>上述头文件是在<code>statx</code>的man手册里写的，但实际使用时似乎还应该包含<code>linux/stat.h</code>头文件。</p>
<h3 id="简介-13"><a class="header" href="#简介-13">简介</a></h3>
<p>该系统调用的功能类似与<code>newfstatat</code>，但是，其提供的信息的类型是<code>struct statx</code>而不是<code>struct stat</code>，其包含的信息更多。</p>
<p>使用该函数的方式与<code>fstatat</code>类似，其中<code>mask</code>表示的是用户感兴趣的字段。也就是说，我们可以通过<code>mask</code>让返回的<code>statxbuf</code>只有部分字段有意义，其余不感兴趣的字段不需要内核来填充。其提供的标志位包括：</p>
<ul>
<li><code>STATX_TYPE</code>: 得到<code>stx_mode &amp; S_IFMT</code></li>
<li><code>STATX_MODE</code>: 得到<code>stx_mode &amp; ~S_IFMT</code></li>
<li><code>STATX_NLINK</code>: 得到<code>stx_nlink</code></li>
<li><code>STATX_UID</code>: 得到<code>stx_uid</code></li>
<li><code>STATX_GID</code>: 得到<code>stx_gid</code></li>
<li><code>STATX_ATIME</code>: 得到<code>stx_atime</code></li>
<li><code>STATX_MTIME</code>: 得到<code>stx_mtime</code></li>
<li><code>STATX_CTIME</code>: 得到<code>stx_ctime</code></li>
<li><code>STATX_INO</code>: 得到<code>stx_ino</code></li>
<li><code>STATX_SIZE</code>: 得到<code>stx_size</code></li>
<li><code>STATX_BLOCKS</code>: 得到<code>stx_blocks</code></li>
<li><code>STATX_BASIC_STATS</code>: 得到上述全部</li>
<li><code>STATX_BTIME</code>: 得到<code>stx_btime</code></li>
<li><code>STATX_ALL</code>: 得到所有的字段</li>
</ul>
<p>该结构体的内容是：</p>
<pre><code class="language-c">struct statx {
	__u32	stx_mask;	/* What results were written [uncond] */
	__u32	stx_blksize;	/* Preferred general I/O size [uncond] */
	__u64	stx_attributes;	/* Flags conveying information about the file [uncond] */
	__u32	stx_nlink;	/* Number of hard links */
	__u32	stx_uid;	/* User ID of owner */
	__u32	stx_gid;	/* Group ID of owner */
	__u16	stx_mode;	/* File mode */
	__u16	__spare0[1];
	__u64	stx_ino;	/* Inode number */
	__u64	stx_size;	/* File size */
	__u64	stx_blocks;	/* Number of 512-byte blocks allocated */
	__u64	stx_attributes_mask; /* Mask to show what's supported in stx_attributes */
	struct statx_timestamp	stx_atime;	/* Last access time */
	struct statx_timestamp	stx_btime;	/* File creation time */
	struct statx_timestamp	stx_ctime;	/* Last attribute change time */
	struct statx_timestamp	stx_mtime;	/* Last data modification time */
	__u32	stx_rdev_major;	/* Device ID of special file [if bdev/cdev] */
	__u32	stx_rdev_minor;
	__u32	stx_dev_major;	/* ID of device containing file [uncond] */
	__u32	stx_dev_minor;
	__u64	__spare2[14];	/* Spare space for future expansion */
};
</code></pre>
<p>其与<code>struct stat</code>的主要区别在于：</p>
<ul>
<li><code>stx_mask</code>: 即传入的<code>mask</code>参数，表示哪些字段有意义</li>
<li><code>stx_attributes</code>: 该文件更多的状态信息。其主要包含如下标志位：
<ul>
<li><code>STATX_ATTR_IMMUTABLE</code>: 该文件不能被修改</li>
<li><code>STATX_ATTR_APPEND</code>: 该文件只能以append模式写入，也就是说每次写入都必须在文件最后</li>
<li><code>STATX_ATTR_DAX</code>: 该文件处于DAX状态（CPU直接访问）。TODO：进一步解释</li>
</ul>
</li>
<li><code>stx_attributes_mask</code>: 掩码，用于表示<code>stx_attributes</code>的哪些标志位被设置了（有可能有的标志位没有被操作系统设置，而不是没有包含该标志位）</li>
</ul>
<h3 id="实现-12"><a class="header" href="#实现-12">实现</a></h3>
<p>其实现与<code>stat</code>等系统调用相同。内核会根据系统调用的类型，确定一个内部的掩码，根据掩码获得相应的文件信息。</p>
<h1 id="eventfd-eventfd2系统调用"><a class="header" href="#eventfd-eventfd2系统调用"><code>eventfd</code>, <code>eventfd2</code>系统调用</a></h1>
<h2 id="系统调用号-14"><a class="header" href="#系统调用号-14">系统调用号</a></h2>
<ul>
<li><code>eventfd</code>: 284</li>
<li><code>eventfd2</code>: 290</li>
</ul>
<h2 id="函数原型-9"><a class="header" href="#函数原型-9">函数原型</a></h2>
<h3 id="内核接口-14"><a class="header" href="#内核接口-14">内核接口</a></h3>
<pre><code class="language-c">asmlinkage long sys_eventfd(unsigned int count);
asmlinkage long sys_eventfd2(unsigned int count, int flags);
</code></pre>
<h3 id="glibc封装-14"><a class="header" href="#glibc封装-14">glibc封装</a></h3>
<pre><code class="language-c">#include &lt;sys/eventfd.h&gt;

int eventfd(unsigned int initval, int flags);
</code></pre>
<h2 id="简介-14"><a class="header" href="#简介-14">简介</a></h2>
<p>自内核 2.6.22 起，Linux 通过 <code>eventfd()</code> 系统调用额外提供了一种非标准的同步机制。这个系统调用创建了一个 <code>eventfd</code> 对象，该对象拥有一个相关的由内核维护的 8 字节无符号整数。通知机制就建立在这个无符号整数的数值变化上。</p>
<p>这个系统调用返回一个指向该 <code>eventfd</code> 的文件描述符。用户可以对这个文件描述符使用 <code>read</code> 或 <code>write</code> 系统调用，来操作由内核维护的数值。</p>
<p>此外，<code>eventfd</code> 可以和 <code>epoll</code> 等多路复用的系统调用一同使用：我们可以使用多路复用的系统调用测试对象值是否为非零，如果是非零的话就表示文件描述符可读。</p>
<p>在 linux 2.6.22 之后，<code>eventfd</code> 可用。在 linux 2.6.27 之后，<code>eventfd2</code> 可用。他们二者的区别是，<code>eventfd</code> 系统调用没有 <code>flags</code> 参数。而 glibc 从2.9开始，提供的 <code>eventfd</code> 底层则会调用 <code>eventfd2</code> 来进行实现（如果 <code>eventfd2</code> 被内核支持的话）。</p>
<p>因此如果内核版本不支持，您务必要将 <code>flags</code> 设置为0，除此之外这两个系统调用没有差别。</p>
<h2 id="使用-1"><a class="header" href="#使用-1">使用</a></h2>
<h3 id="函数签名-5"><a class="header" href="#函数签名-5">函数签名</a></h3>
<pre><code class="language-c">int eventfd(unsigned int initval, int flags);
</code></pre>
<ul>
<li>
<p><code>unsigned int initval</code>: 内核中维护的无符号整数的初始值，我们一般叫它 counter</p>
</li>
<li>
<p><code>int flags</code>: </p>
<ul>
<li>2.6.26 及之前，这个flags还不支持，必须设置成0</li>
<li>flags 设置后，会影响对 <code>eventfd</code> 对象操作（如 <code>read</code> <code>write</code>）时的行为，有三种：
<ul>
<li><code>EFD_CLOEXEC</code></li>
<li><code>EFD_NONBLOCK</code></li>
<li><code>EFD_SEMAPHORE</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>return val int</code>: 返回一个指向该对象的文件描述符</p>
</li>
</ul>
<h3 id="配合-read-和-write-使用"><a class="header" href="#配合-read-和-write-使用">配合 <code>read</code> 和 <code>write</code> 使用</a></h3>
<ul>
<li><code>read(2)</code>
<ul>
<li><code>EFD_SEMAPHORE</code> 如果没有被设置，从 eventfd read，会得到 counter，并将它归0</li>
<li><code>EFD_SEMAPHORE</code> 如果被设置，从 eventfd read，会得到值 1，并将 counter - 1</li>
<li>counter 为 0 时，对它进行 read
<ul>
<li><code>EFD_NONBLOCK</code> 如果被设置，那么会以 <code>EAGAIN</code> 的错失败</li>
<li>否则 read 会被阻塞，直到为非0。</li>
</ul>
</li>
</ul>
</li>
<li><code>write(2)</code>
<ul>
<li>会把一个 8 字节的int值写入到 counter 里</li>
<li>最大值是 2^64 - 1</li>
<li>如果写入时会发生溢出，则write会被阻塞
<ul>
<li>如果 EFD_NONBLOCK 被设置，那么以 EAGAIN 失败</li>
</ul>
</li>
<li>以不合法的值写入时，会以 EINVAL 失败
<ul>
<li>比如 0xffffffffffffffff 不合法</li>
<li>比如 写入的值 size 小于8字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="配合多路复用使用"><a class="header" href="#配合多路复用使用">配合多路复用使用</a></h3>
<p><code>poll(2)</code>,  <code>select(2)</code>, <code>epoll(7)</code></p>
<ul>
<li>作为被监听的 fd 用于多路复用API</li>
<li>如果 counter 的值大于 0 ，那么 fd 的状态就是「可读的」
<ul>
<li><code>select</code> 中 <code>readfds</code> 生效</li>
<li><code>poll</code> 中 <code>POLLIN</code> 生效</li>
</ul>
</li>
<li>如果能无阻塞地写入一个至少为 1 的值，那么 fd 的状态就是「可写的」
<ul>
<li><code>select</code> 中 <code>writefds</code> 生效</li>
<li><code>poll</code> 中 <code>POLLOUT</code> 生效</li>
</ul>
</li>
</ul>
<h2 id="作用"><a class="header" href="#作用">作用</a></h2>
<ul>
<li>所有通过 pipe(2) 来进行**通知（而非数据传输）**操作的，都可以用 <code>eventfd(2)</code> 来代替
<ul>
<li>节省文件描述符资源：pipe需要两个文件描述符，eventfd只需要一个</li>
<li>内存开销小：内核管理层面，后者开销比前者低
<ul>
<li>后者只需要一个counter，8字节大小</li>
<li>前者在内核和用户态之间会来回拷贝多次，还会分配额外的虚拟内存页</li>
</ul>
</li>
</ul>
</li>
<li>提供了内核台与用户态之间沟通的桥梁
<ul>
<li>比如kernel AIO，内核在事件完成后可以通过eventfd，通知用户态结构</li>
</ul>
</li>
<li><code>eventfd</code> 既可以监听传统的文件，也可以监听内核提供的类似<code>epoll</code>、<code>select</code>实例文件</li>
<li><code>eventfd</code> 是并发安全的</li>
</ul>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<p>使用效果：</p>
<pre><code class="language-plaintext">$ ./a.out 1 2 4 7 14
Child writing 1 to efd
Child writing 2 to efd
Child writing 4 to efd
Child writing 7 to efd
Child writing 14 to efd
Child completed write loop
Parent about to read
Parent read 28 (0x1c) from efd
</code></pre>
<p>源代码：</p>
<pre><code class="language-c">#include &lt;sys/eventfd.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;             /* Definition of uint64_t */

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)
// 这个例子展示了 eventfd 在进程间通知的作用
int
main(int argc, char *argv[])
{
    int efd, j;
    uint64_t u;
    ssize_t s;
   // 接受至少一个数字
   if (argc &lt; 2) {
        fprintf(stderr, &quot;Usage: %s &lt;num&gt;...\n&quot;, argv[0]);
        exit(EXIT_FAILURE);
    }
   // flags 为 0
   // 初始值为 0
   efd = eventfd(0, 0);
   if (efd == -1)
        handle_error(&quot;eventfd&quot;);
   // fork 出子进程
   switch (fork()) {
    case 0: // 子进程下执行
        for (j = 1; j &lt; argc; j++) {
            // 子进程负责把传入的参数写到 counter 里
            printf(&quot;Child writing %s to efd\n&quot;, argv[j]);
            u = strtoull(argv[j], NULL, 0);
                    /* strtoull() allows various bases */
            s = write(efd, &amp;u, sizeof(uint64_t));
            if (s != sizeof(uint64_t))
                handle_error(&quot;write&quot;);
        }
        printf(&quot;Child completed write loop\n&quot;);

       exit(EXIT_SUCCESS);

   default: // 父进程下
        sleep(2); // 父进程暂时阻塞

       printf(&quot;Parent about to read\n&quot;);
       	// 阻塞结束后，父进程应当读到子进程写入的值之和
        s = read(efd, &amp;u, sizeof(uint64_t));
        if (s != sizeof(uint64_t))
            handle_error(&quot;read&quot;);
        printf(&quot;Parent read %llu (0x%llx) from efd\n&quot;,
                (unsigned long long) u, (unsigned long long) u);
        exit(EXIT_SUCCESS);

   case -1:
        handle_error(&quot;fork&quot;);
    }
}
</code></pre>
<p>你可以修改一下代码，体验一下它如何通过 <code>read</code> <code>write</code> 进行通知作用的。</p>
<h2 id="实现-13"><a class="header" href="#实现-13">实现</a></h2>
<p>eventfd 的实现位于Linux内核的<code>fs/eventfd.c</code>文件中。其中 <code>struct eventfd_ctx</code> 即是我们上文所说的 <code>counter</code> 。</p>
<pre><code class="language-c">struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	/*
	 * Every time that a write(2) is performed on an eventfd, the
	 * value of the __u64 being written is added to &quot;count&quot; and a
	 * wakeup is performed on &quot;wqh&quot;. A read(2) will return the &quot;count&quot;
	 * value to userspace, and will reset &quot;count&quot; to zero. The kernel
	 * side eventfd_signal() also, adds to the &quot;count&quot; counter and
	 * issue a wakeup.
	 */
	__u64 count;
	unsigned int flags;
	int id;
};
</code></pre>
<p>可以看到，<code>eventfd</code> 的实现其实就是通过内核维护的一个等待队列来控制进程的唤醒和阻塞。</p>
<p>TODO：</p>
<ul>
<li>详细的 <code>eventfd</code> 的分析</li>
<li><code>eventfd</code> 和多路复用系统调用的配合使用例子。</li>
</ul>
<h1 id="mmap-munmap-mremap-msync-remap_file_pages系统调用"><a class="header" href="#mmap-munmap-mremap-msync-remap_file_pages系统调用"><code>mmap</code>, <code>munmap</code>, <code>mremap</code>, <code>msync</code>, <code>remap_file_pages</code>系统调用</a></h1>
<h2 id="mmap"><a class="header" href="#mmap"><code>mmap</code></a></h2>
<h3 id="系统调用号-15"><a class="header" href="#系统调用号-15">系统调用号</a></h3>
<p>9</p>
<h3 id="函数签名-6"><a class="header" href="#函数签名-6">函数签名</a></h3>
<h4 id="内核接口-15"><a class="header" href="#内核接口-15">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_mmap(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, off_t pgoff);
</code></pre>
<h4 id="glibc封装-15"><a class="header" href="#glibc封装-15">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;sys/mman.h&gt;
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<h3 id="简介-15"><a class="header" href="#简介-15">简介</a></h3>
<p><code>mmap</code>做了一个特别神奇的事：把硬盘上的文件与内存之间建立映射。首先，我们来看看最终效果。假设我们有一个二进制文件<code>data.bin</code>，其内容为（16进制）：</p>
<pre><code class="language-plaintext">11 45 14 19 19 81 00
</code></pre>
<p>我们通过<code>mmap</code>，将这个文件映射到了内存中从<code>0x10000</code>开始的区域。接下来，如果我们的程序从内存<code>0x10002</code>读取2字节的内容，将得到<code>0x1914</code>这个数字（小端序）。</p>
<p>也就是说，我们没有借助<code>read</code>系统调用，而是直接对某个内存区域进行读取，就能读取到硬盘上的文件的内容。</p>
<p>接着我们来看看其参数。</p>
<p>总得来说，<code>mmap</code>的行为是，在<code>flags</code>的控制下，将描述符为<code>fd</code>的文件中，从<code>offset</code>位置开始，<code>length</code>个字节映射到地址为<code>addr</code>的内存空间中，并设置其内存保护为<code>prot</code>。</p>
<p>在一般情况下，地址和长度应遵守这样的限制：</p>
<ul>
<li>如果<code>addr</code>为<code>NULL</code>，则内核自己选择适当的内存地址进行映射。如果其不为<code>NULL</code>，则内核以<code>addr</code>的值为参考，选择一个适当的内存地址进行映射（一般是之后最近的页边界）。</li>
<li><code>offset</code>应为页大小的倍数。</li>
<li><code>length</code>应大于0。如果被映射的大小不是页大小的整数倍，则剩下的页的部分会被0填充。</li>
</ul>
<p>控制<code>mmap</code>行为的核心为<code>flags</code>。其可以包含以下标志位：</p>
<ul>
<li>
<p>核心标志位</p>
<p>以下三个标志位必须且只能包含一个。</p>
<ul>
<li>
<p><code>MAP_SHARED</code></p>
<p>建立一个共享的映射。</p>
<p>如果在该进程中，对该映射后的内存区域进行修改，那么在别的进程中，如果其使用了<code>mmap</code>，将同一个文件也进行了映射，那么可以同步看见该修改。同时被映射的文件也会被修改。</p>
</li>
<li>
<p><code>MAP_SHARED_VALIDATE</code></p>
<p>行为和<code>MAP_SHARED</code>类似。但是会核验<code>flags</code>，如果其包含了未知的标志位，将报错<code>EOPNOTSUPP</code>。</p>
</li>
<li>
<p><code>MAP_PRIVATE</code></p>
<p>建立一个私有的写时复制（copy-on-write）的映射。</p>
<p>对该映射的内存区域进行的修改不会同步到其他进程中，也不会修改硬盘里相应的文件。</p>
</li>
</ul>
</li>
<li>
<p>附加标志位</p>
<p>除了三个必要的标志位之外，还有一些标志位也可以被包含。其主要包括</p>
<ul>
<li>
<p><code>MAP_ANONYMOUS</code></p>
<p>忽略<code>fd</code>，被映射的内存区域将被初始化为0。</p>
<p>此时<code>fd</code>应为-1，<code>offset</code>应为0。</p>
</li>
<li>
<p><code>MAP_FIXED</code></p>
<p>将<code>addr</code>看作确切的地址，而非一个参考。</p>
<p>内核将准确地将文件映射到从<code>addr</code>开始的内存区域。如果这个映射与之前已经存在的内存映射有重合，则重合的部分将被新的映射覆盖。</p>
</li>
<li>
<p><code>MAP_FIXED_NOREPLACE</code></p>
<p>行为和<code>MAP_FIXED</code>类似，但不会覆盖已有的内存映射。如果与已有的内存映射有重合，那么将直接返回错误<code>EEXIST</code>。</p>
</li>
</ul>
</li>
</ul>
<p><code>prot</code>参数则是控制映射的内存区域的内存保护，其可能的值包括</p>
<ul>
<li>
<p><code>PROC_EXEC</code></p>
<p>页可执行</p>
</li>
<li>
<p><code>PROC_READ</code></p>
<p>页可读</p>
</li>
<li>
<p><code>PROC_WRITE</code></p>
<p>页可写</p>
</li>
<li>
<p><code>PROC_NONE</code></p>
<p>页不可访问</p>
</li>
</ul>
<p>使用<code>mmap</code>读取文件的好处在于：使用<code>read</code>读取文件时，会先将文件的内容从硬盘上复制到内核的内存空间中，然后再由内核将数据复制到用户的内存空间中。但使用<code>mmap</code>时，文件的内容是可以直接复制到用户的内存空间中的。</p>
<h3 id="实现-14"><a class="header" href="#实现-14">实现</a></h3>
<p><code>mmap</code>的实现位于Linux内核源码的<code>arch/x86/kernel/sys_x86_64.c</code>，其直接调用了位于<code>mm/mmap.c</code>的<code>ksys_mmap_pgoff</code>函数。在经过了复杂的函数链之后，我们可以发现，其最终是调用的位于<code>include/linux/fs.h</code>的<code>call_mmap</code>函数：</p>
<pre><code class="language-c">static inline int call_mmap(struct file *file, struct vm_area_struct *vma)
{
	return file-&gt;f_op-&gt;mmap(file, vma);
}
</code></pre>
<p>其中<code>struct vm_area_struct</code>这个结构体，表示一块虚拟内存，其包含一个类型为<code>struct vm_operations_struct</code>的字段<code>vm_ops</code>，表示对虚拟内存的操作，其定义在<code>include/linux/mm.h</code>:</p>
<pre><code class="language-c">/*
 * These are the virtual MM functions - opening of an area, closing and
 * unmapping it (needed to keep files on disk up-to-date etc), pointer
 * to the functions called when a no-page or a wp-page exception occurs.
 */
struct vm_operations_struct {
	void (*open)(struct vm_area_struct * area);
	void (*close)(struct vm_area_struct * area);
	int (*split)(struct vm_area_struct * area, unsigned long addr);
	int (*mremap)(struct vm_area_struct * area);
	vm_fault_t (*fault)(struct vm_fault *vmf);
	vm_fault_t (*huge_fault)(struct vm_fault *vmf,
			enum page_entry_size pe_size);
	void (*map_pages)(struct vm_fault *vmf,
			pgoff_t start_pgoff, pgoff_t end_pgoff);
	unsigned long (*pagesize)(struct vm_area_struct * area);

	/* notification that a previously read-only page is about to become
	 * writable, if an error is returned it will cause a SIGBUS */
	vm_fault_t (*page_mkwrite)(struct vm_fault *vmf);

	/* same as page_mkwrite when using VM_PFNMAP|VM_MIXEDMAP */
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *vmf);

	/* called by access_process_vm when get_user_pages() fails, typically
	 * for use by special VMAs that can switch between memory and hardware
	 */
	int (*access)(struct vm_area_struct *vma, unsigned long addr,
		      void *buf, int len, int write);

	/* Called by the /proc/PID/maps code to ask the vma whether it
	 * has a special name.  Returning non-NULL will also cause this
	 * vma to be dumped unconditionally. */
	const char *(*name)(struct vm_area_struct *vma);

#ifdef CONFIG_NUMA
	/*
	 * set_policy() op must add a reference to any non-NULL @new mempolicy
	 * to hold the policy upon return.  Caller should pass NULL @new to
	 * remove a policy and fall back to surrounding context--i.e. do not
	 * install a MPOL_DEFAULT policy, nor the task or system default
	 * mempolicy.
	 */
	int (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);

	/*
	 * get_policy() op must add reference [mpol_get()] to any policy at
	 * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure
	 * in mm/mempolicy.c will do this automatically.
	 * get_policy() must NOT add a ref if the policy at (vma,addr) is not
	 * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.
	 * If no [shared/vma] mempolicy exists at the addr, get_policy() op
	 * must return NULL--i.e., do not &quot;fallback&quot; to task or system default
	 * policy.
	 */
	struct mempolicy *(*get_policy)(struct vm_area_struct *vma,
					unsigned long addr);
#endif
	/*
	 * Called by vm_normal_page() for special PTEs to find the
	 * page for @addr.  This is useful if the default behavior
	 * (using pte_page()) would not find the correct page.
	 */
	struct page *(*find_special_page)(struct vm_area_struct *vma,
					  unsigned long addr);
};
</code></pre>
<p>和我们的<code>mmap</code>有关的字段是</p>
<pre><code class="language-c">vm_fault_t (*fault)(struct vm_fault *vmf);
</code></pre>
<p>这个函数指针将在我们出现页错误的时候调用。</p>
<p>我们上面看到，<code>mmap</code>最终落实到了各个文件类型自己定义的<code>mmap</code>操作中。我们常见的EXT4文件系统中，这个操作为函数<code>ext4_file_mmap</code>:</p>
<pre><code class="language-c">static const struct vm_operations_struct ext4_file_vm_ops = {
	.fault		= ext4_filemap_fault,
	.map_pages	= filemap_map_pages,
	.page_mkwrite   = ext4_page_mkwrite,
};

static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	struct inode *inode = file-&gt;f_mapping-&gt;host;
	struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);
	struct dax_device *dax_dev = sbi-&gt;s_daxdev;

	if (unlikely(ext4_forced_shutdown(sbi)))
		return -EIO;

	/*
	 * We don't support synchronous mappings for non-DAX files and
	 * for DAX files if underneath dax_device is not synchronous.
	 */
	if (!daxdev_mapping_supported(vma, dax_dev))
		return -EOPNOTSUPP;

	file_accessed(file);
	if (IS_DAX(file_inode(file))) {
		vma-&gt;vm_ops = &amp;ext4_dax_vm_ops;
		vma-&gt;vm_flags |= VM_HUGEPAGE;
	} else {
		vma-&gt;vm_ops = &amp;ext4_file_vm_ops;
	}
	return 0;
}
</code></pre>
<p>可以看到，在通常情况下，是使用<code>ext4_filemap_fault</code>作为我们之前讲的<code>vm_operations_struct</code>中的<code>fault</code>字段。这个函数最终会被落实到<code>mm/filemap.c</code>的<code>filemap_fault</code>函数。在这个函数中，如果这个文件在内核的页缓存中，则直接去找那个页即可。如果没有，则调用<code>pagecache_get_page</code>，最终使用<code>__add_to_page_cache_locked</code>创建相应的页。</p>
<h2 id="munmap"><a class="header" href="#munmap"><code>munmap</code></a></h2>
<h3 id="系统调用号-16"><a class="header" href="#系统调用号-16">系统调用号</a></h3>
<p>11</p>
<h3 id="函数签名-7"><a class="header" href="#函数签名-7">函数签名</a></h3>
<h4 id="内核接口-16"><a class="header" href="#内核接口-16">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_munmap(unsigned long addr, size_t len);
</code></pre>
<h4 id="glibc封装-16"><a class="header" href="#glibc封装-16">glibc封装</a></h4>
<pre><code class="language-c">#include &lt;sys/mman.h&gt;
int munmap(void *addr, size_t length);
</code></pre>
<h3 id="简介-16"><a class="header" href="#简介-16">简介</a></h3>
<p>在使用<code>mmap</code>将文件映射到内存空间之后，即使我们使用<code>close</code>关闭被映射的文件的描述符，该映射依然存在。如果需要取消相应的映射，我们可以使用<code>munmap</code>。</p>
<p><code>munmap</code>接受两个参数，表示需要取消映射的内存范围，其中，<code>addr</code>需要是页大小的整数倍。对于从<code>addr</code>开始，长度为<code>length</code>的内存区域，只要某个通过<code>mmap</code>建立的内存映射与该区域有交集，那么相应的内存映射就将被取消。</p>
<h3 id="实现-15"><a class="header" href="#实现-15">实现</a></h3>
<p><code>munmap</code>的实现位于Linux内核源码的<code>mm/mmap.c</code>文件中，其核心代码为<code>__do_munmap</code>函数：</p>
<h2 id="mremap"><a class="header" href="#mremap"><code>mremap</code></a></h2>
<h3 id="系统调用号-17"><a class="header" href="#系统调用号-17">系统调用号</a></h3>
<p>25</p>
<h3 id="函数签名-8"><a class="header" href="#函数签名-8">函数签名</a></h3>
<h4 id="内核接口-17"><a class="header" href="#内核接口-17">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_mremap(unsigned long addr, unsigned long old_len, unsigned long new_len, unsigned long flags, unsigned long new_addr);
</code></pre>
<h4 id="glibc封装-17"><a class="header" href="#glibc封装-17">glibc封装</a></h4>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;sys/mman.h&gt;
void *mremap(void *old_address, size_t old_size, size_t new_size, int flags, ... /* void *new_address */);
</code></pre>
<h3 id="简介-17"><a class="header" href="#简介-17">简介</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
