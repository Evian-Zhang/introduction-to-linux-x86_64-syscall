<!DOCTYPE HTML>
<html lang="zh-Hans" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基础知识 - Linux x86_64系统调用简介</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">序</a></li><li class="chapter-item expanded affix "><a href="../src/introduction.html" class="active">基础知识</a></li><li class="chapter-item expanded affix "><li class="part-title">文件系统</li><li class="chapter-item expanded "><a href="../src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><strong aria-hidden="true">1.</strong> open, openat, name_to_handle_at, open_by_handle_at, open_tree</a></li><li class="chapter-item expanded "><a href="../src/filesystem/close.html"><strong aria-hidden="true">2.</strong> close</a></li><li class="chapter-item expanded "><a href="../src/filesystem/read-pread64-readv-preadv-preadv2.html"><strong aria-hidden="true">3.</strong> read, pread64, readv, preadv, preadv2</a></li><li class="chapter-item expanded "><a href="../src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><strong aria-hidden="true">4.</strong> write, pwrite64, writev, pwritev, pwritev2</a></li><li class="chapter-item expanded "><a href="../src/filesystem/lseek.html"><strong aria-hidden="true">5.</strong> lseek</a></li><li class="chapter-item expanded "><a href="../src/filesystem/poll-select-pselect6-ppoll.html"><strong aria-hidden="true">6.</strong> poll, select, pselect6, ppoll</a></li><li class="chapter-item expanded "><a href="../src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><strong aria-hidden="true">7.</strong> epoll_create, epoll_wait, epoll_ctl, epoll_pwait, epoll_create1</a></li><li class="chapter-item expanded "><a href="../src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><strong aria-hidden="true">8.</strong> stat, fstat, lstat, newfstatat, statx</a></li><li class="chapter-item expanded "><a href="../src/filesystem/eventfd-eventfd2.html"><strong aria-hidden="true">9.</strong> eventfd, eventfd2</a></li><li class="chapter-item expanded affix "><li class="part-title">内存管理</li><li class="chapter-item expanded "><a href="../src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><strong aria-hidden="true">10.</strong> mmap, munmap, mremap, msync, remap_file_pages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Linux x86_64系统调用简介</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h1>
<p>在本仓库中，如无特殊说明，处理器指令集默认为x86_64指令集。</p>
<h2 id="系统调用简介"><a class="header" href="#系统调用简介">系统调用简介</a></h2>
<p>在Linux中，内核提供一些操作的接口给用户态的程序使用，这就是系统调用。对于用户态的程序，其调用相应的接口的方式，是一条汇编指令<code>syscall</code>。</p>
<p>比如说，创建子进程的操作，Linux内核提供了<code>fork</code>这个系统调用作为接口。那么，如果用户态程序想调用这个内核提供的接口，其对应的汇编语句为（部分）</p>
<pre><code class="language-x86asm">movq $57, %rax
syscall
</code></pre>
<p><code>syscall</code>这个指令会先查看此时RAX的值，然后找到系统调用号为那个值的系统调用，然后执行相应的系统调用。我们可以在系统调用列表中找到，<code>fork</code>这个系统调用的系统调用号是57。于是，我们把57放入<code>rax</code>寄存器中，然后使用了<code>syscall</code>指令。这就是让内核执行了<code>fork</code>。</p>
<h2 id="调用约定"><a class="header" href="#调用约定">调用约定</a></h2>
<p>提到这个，就不得不说Linux x86_64的调用约定。我们知道，系统调用往往会有许多参数，比如说<code>open</code>这个打开文件的系统操作，我们可以在<code>include/linux/syscalls.h</code>中找到其对应的C语言接口为</p>
<pre><code class="language-c">asmlinkage long sys_open(const char __user *filename, int flags, umode_t mode);
</code></pre>
<p>它接受三个参数。那么，参数传递是按照什么规定呢？事实上，当涉及到系统调用时，调用约定与用户态程序一般的调用约定并不相同。在<a href="https://gitlab.com/x86-psABIs/x86-64-ABI">System V Application Binary Interface AMD64 Architecture Processor Supplement</a>的A.2.1节中我们可以看到：</p>
<blockquote>
<ol>
<li>User-level applications use as integer registers for passing the sequence <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code> and <code>%r9</code>. The kernel interface uses <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%r10</code>, <code>%r8</code> and <code>%r9</code>.</li>
<li>A system-call is done via the <code>syscall</code> instruction. The kernel destroys registers <code>%rcx</code> and <code>%r11</code>.</li>
<li>The number of the syscall has to be passed in register <code>%rax</code>.</li>
<li>System-calls are limited to six arguments, no argument is passed directly on the stack.</li>
<li>Returning from the syscall, register <code>%rax</code> contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is <code>-errno</code>.</li>
<li>Only values of class INTEGER or class MEMORY are passed to the kernel.</li>
</ol>
</blockquote>
<p>比较重要的是前五点。从这五点我们可以知道，如果要调用<code>open</code>系统调用，那么步骤是：</p>
<ol>
<li>将<code>pathname</code>放入<code>rdi</code>寄存器</li>
<li>将<code>flags</code>放入<code>rsi</code>寄存器</li>
<li>将<code>mode</code>放入<code>rdx</code>寄存器</li>
<li>将<code>open</code>的系统调用号2放入<code>rax</code>寄存器</li>
<li>执行<code>syscall</code>指令</li>
<li>返回值位于<code>rax</code>寄存器</li>
</ol>
<p>我们使用逆向工具查看汇编代码时，就是通过类似以上六步的方法，确定一个系统调用的相关信息的。</p>
<p>这个规范就称为内核接口的调用约定，可以从第一点就显著地看到，这个调用约定与用户态的程序是不同的。也就是说，如果我们用编译器直接编译</p>
<pre><code class="language-c">long sys_open(const char *pathname, int flags, mode_t mode);
</code></pre>
<p>那么，编译出来的可执行程序会认为，这个函数是用户态函数，其传参仍然是按 <code>%rdi</code>, <code>%rsi</code>, <code>%rdx</code>, <code>%rcx</code>, <code>%r8</code>, <code>%r9</code>的顺序，与内核接口不符。因此，gcc提供了一个标签<code>asmlinkage</code>来标记这个函数是内核接口的调用约定：</p>
<pre><code class="language-c">asmlinkage long sys_open(const char *pathname, int flags, mode_t mode);
</code></pre>
<p>当函数前面有这个标签时，编译器编译出的可执行程序就会认为是按内核接口的调用约定对这个函数进行调用的。详情可以看<a href="https://kernelnewbies.org/FAQ/asmlinkage">FAQ/asmlinkage</a>。</p>
<h2 id="glibc封装"><a class="header" href="#glibc封装">glibc封装</a></h2>
<p>当然，我们平时写的代码中，99%不会直接用到上述的系统调用方法。当我们真的去写一个C程序时：</p>
<pre><code class="language-c">// syscall-wrapper-test.c
#include &lt;unistd.h&gt;

int main() {
    fork();
    return 0;
}
</code></pre>
<p>然后我们将其编译为汇编代码</p>
<pre><code class="language-shell">gcc syscall-wrapper-test.c -S -o syscall-wrapper-test.S
</code></pre>
<p>只能看到这个指令：</p>
<pre><code class="language-x86asm">callq fork
</code></pre>
<p>然后在整个汇编文件中都不会找到<code>fork</code>这个函数的实现。甚至我们如果将其编译为可执行程序</p>
<pre><code class="language-shell">gcc syscall-wrapper-test.c -o syscall-wrapper-test
</code></pre>
<p>然后用逆向工具去反汇编，也会发现整个可执行程序中也不会有<code>fork</code>的实现，同时也不会找到任何对57这个系统调用号进行<code>syscall</code>的代码。</p>
<p>这是因为，我们在Linux上编写的程序，通常都会链接到glibc的动态链接库。我们用</p>
<pre><code class="language-shell">ldd syscall-wrapper-list
</code></pre>
<p>查看其链接的动态链接库，就会看到</p>
<pre><code class="language-plaintext">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6
</code></pre>
<p>而glibc则提供了许多系统调用的封装。这使我们在编写程序的时候，并不需要直接和内核进行交互，而是借用glibc这层封装，更加安全、稳定地使用。关于glibc对系统调用的封装，详情请见官方文档<a href="https://sourceware.org/glibc/wiki/SyscallWrappers">SyscallWrappers</a>。</p>
<p>此外，glibc还提供一个特殊的封装——<code>syscall</code>:</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
long syscall(long number, ...);
</code></pre>
<p>这可以看作汇编指令<code>syscall</code>的封装。比如说，我们想自己实现一个<code>open</code>函数：</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/types.h&gt;

long my_open(const char *pathname, int flags, mode_t mode) {
    return syscall(SYS_open, pathname, flags, mode);
}
</code></pre>
<p>其中，<code>SYS_open</code>为一个宏，定义在<code>sys/syscall.h</code>头文件中，其值为2，也就是<code>open</code>系统调用的系统调用号。</p>
<p>当然，如果真的想在可执行程序中直接对内核进行系统调用，可以把glibc静态链接：</p>
<pre><code class="language-shell">gcc syscall-wrapper-test.c -static -o syscall-wrapper-test
</code></pre>
<p>然后在<code>syscall-wrapper-test</code>这个可执行程序中就可以看到直接的<code>syscall</code>了。</p>
<p>对glibc的动态链接和静态链接各有利弊。对于恶意软件编写者来说，他们往往倾向于静态链接恶意软件。这是因为，分析者可以轻松地写一个动态链接库，将其使用的glibc中的API hook住，改变其行为，使它达不成目的。而如果静态链接，那么分析者只有通过修改内核等比较麻烦的方案才能改变其行为。而静态链接的坏处则在于，如果简单地使用<code>-static</code>选项进行静态链接，就是把整个库都链接进最终的可执行程序中。这会导致库中许多没有被用到的函数的代码也在可执行程序中，使可执行程序的体积增大。解决方案可以参考gcc的官方文档<a href="https://gcc.gnu.org/onlinedocs/gnat_ugn/Compilation-options.html">Compilation-options</a>。</p>
<h2 id="内核接口"><a class="header" href="#内核接口">内核接口</a></h2>
<p>我们之前提到，在Linux内核中，可以在<code>include/linux/syscalls.h</code>文件中找到系统调用函数的声明（会加上<code>sys_</code>前缀）。而其实现则是使用<code>SYSCALL_DEFINEn</code>这个宏。比如说，我们在<code>fs/open.c</code>中可以看到</p>
<pre><code class="language-c">SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
	/* ... */
}
</code></pre>
<p>这代表：</p>
<ul>
<li>内核提供了一个接口，接受三个参数</li>
<li>这个接口叫<code>open</code></li>
<li>第一个参数的类型是<code>const char __user *</code>，参数名为<code>filename</code></li>
<li>第二个参数的类型是<code>int</code>，参数名是<code>flags</code></li>
<li>第三个参数的类型是<code>umode_t</code>，参数名是<code>mode</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
