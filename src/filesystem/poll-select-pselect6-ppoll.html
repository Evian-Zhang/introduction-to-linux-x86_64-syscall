<!DOCTYPE HTML>
<html lang="zh-Hans" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>poll, select, pselect6, ppoll - Linux x86_64系统调用简介</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">序</a></li><li class="chapter-item expanded affix "><a href="../../src/introduction.html">基础知识</a></li><li class="chapter-item expanded affix "><li class="part-title">文件系统</li><li class="chapter-item expanded "><a href="../../src/filesystem/open-openat-name_to_handle_at-open_by_handle_at-open_tree.html"><strong aria-hidden="true">1.</strong> open, openat, name_to_handle_at, open_by_handle_at, open_tree</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/close.html"><strong aria-hidden="true">2.</strong> close</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/read-pread64-readv-preadv-preadv2.html"><strong aria-hidden="true">3.</strong> read, pread64, readv, preadv, preadv2</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/write-pwrite64-writev-pwritev-pwritev2.html"><strong aria-hidden="true">4.</strong> write, pwrite64, writev, pwritev, pwritev2</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/lseek.html"><strong aria-hidden="true">5.</strong> lseek</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/poll-select-pselect6-ppoll.html" class="active"><strong aria-hidden="true">6.</strong> poll, select, pselect6, ppoll</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html"><strong aria-hidden="true">7.</strong> epoll_create, epoll_wait, epoll_ctl, epoll_pwait, epoll_create1</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/stat-fstat-lstat-newfstatat-statx.html"><strong aria-hidden="true">8.</strong> stat, fstat, lstat, newfstatat, statx</a></li><li class="chapter-item expanded "><a href="../../src/filesystem/eventfd-eventfd2.html"><strong aria-hidden="true">9.</strong> eventfd, eventfd2</a></li><li class="chapter-item expanded affix "><li class="part-title">内存管理</li><li class="chapter-item expanded "><a href="../../src/memory_management/mmap-munmap-mremap-msync-remap_file_pages.html"><strong aria-hidden="true">10.</strong> mmap, munmap, mremap, msync, remap_file_pages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Linux x86_64系统调用简介</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="poll-select-pselect6-ppoll系统调用"><a class="header" href="#poll-select-pselect6-ppoll系统调用"><code>poll</code>, <code>select</code>, <code>pselect6</code>, <code>ppoll</code>系统调用</a></h1>
<h2 id="select与poll"><a class="header" href="#select与poll"><code>select</code>与<code>poll</code></a></h2>
<h3 id="系统调用号"><a class="header" href="#系统调用号">系统调用号</a></h3>
<p><code>poll</code>为7，<code>select</code>为23。</p>
<h3 id="函数原型"><a class="header" href="#函数原型">函数原型</a></h3>
<h4 id="内核接口"><a class="header" href="#内核接口">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_poll(struct pollfd __user *ufds, unsigned int nfds, int timeout);
asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp, fd_set __user *exp, struct timeval __user *tvp);
</code></pre>
<h4 id="glibc封装"><a class="header" href="#glibc封装">glibc封装</a></h4>
<p><code>poll</code></p>
<pre><code class="language-c">#include &lt;poll.h&gt;
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre>
<p><code>select</code></p>
<pre><code class="language-c">#include &lt;sys/select.h&gt;
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<p><code>select</code>与<code>poll</code>都是为了实现IO多路复用的功能。</p>
<p>一般来说，对硬盘上的文件的读取都不会阻塞。但是，对管道、套接字、伪终端等文件的读取，是可能产生阻塞的。举个例子来说，如果我们读取<code>stdin</code>：</p>
<pre><code class="language-c">int fd = STDIN_FILENO; // stdin
char buf[64];
read(fd, buf, 64); // blocks here
process_read_content(buf);
</code></pre>
<p>那么，在执行<code>read</code>时，如果我们一直不向终端输入，那么这里会始终阻塞着，程序永远不会执行到之后的<code>process_read_context(buf)</code>。在这种情况下，这种行为是符合逻辑的，因为我们之后的语句是依赖读入的内容<code>buf</code>的。所以除非我们收到了<code>buf</code>的内容，否则就不应该执行之后的指令。</p>
<p>但是，如果有多个文件需要读入，就产生了问题。假设我们有一个<code>nfd</code>个元素的文件描述符数组<code>fds</code>，我们需要对他们读入，并彼此独立地分别处理每个读入的内容。</p>
<ul>
<li>
<p>方案一</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    for (int i = 0; i &lt; nfd; i++) {
        char buf[64];
        read(fds[i], buf, 64);
        process_read_content(buf);
    }
}
</code></pre>
<p>这个方案能完成我们的需求，但是效率实在是太低了。由于是按顺序依次处理读入的内容，如果<code>fds[0]</code>始终没有输入，但是<code>fds[1]</code>早就有了输入。我们明明可以先处理<code>fds[1]</code>的输入的，但是由于进程阻塞在了<code>fds[0]</code>的<code>read</code>操作中，我们的时间就这样被白白浪费了。</p>
</li>
<li>
<p>方案二</p>
<p>既然每个文件描述符处理读入是互相独立的，我们就可以创建<code>nfd</code>个线程，每个线程中处理其读入。</p>
<p>这种方案确实可以解决我们方案一中的问题，但是线程的创建、线程之间的切换是非常耗费时间的。</p>
</li>
</ul>
<p>为了更高效地解决这个问题，我们可以增加一个新的操作——判断某个文件描述符是否可以读入。我们可以遍历文件描述符，判断是否有已经可以读入的，如果有的话就直接处理，如果没有的话就再次遍历。这样几乎没有耗费的时间。</p>
<p>我们甚至可以想出更高效的方案，在主线程中查询是否有可以读取的文件描述符，然后把可以读取的文件描述符给别的线程执行。</p>
<p><code>select</code>就为我们提供了一个类似的解决方案。我们给<code>select</code>传入需要检测IO状态（可以读入、可以写入等）的文件描述符集合，<code>select</code>立即返回，告诉我们哪些文件描述符的IO已经准备就绪。</p>
<p><code>poll</code>的功能和<code>select</code>类似，但解决了一些<code>select</code>的缺点。具体请见下面的用法一节。</p>
<h3 id="用法"><a class="header" href="#用法">用法</a></h3>
<h4 id="select"><a class="header" href="#select"><code>select</code></a></h4>
<p><code>select</code>的函数签名为</p>
<pre><code class="language-c">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre>
<p><code>readfds</code>, <code>writefds</code>和<code>exceptfds</code>是文件描述符集合，分别用于：</p>
<ul>
<li>
<p><code>readfds</code></p>
<p>已经准备好供读取的文件描述符集合，即<code>read</code>操作不会阻塞。</p>
</li>
<li>
<p><code>writefds</code></p>
<p>已经准备好供写入的文件描述符集合，即<code>write</code>操作不会阻塞。</p>
</li>
<li>
<p><code>exceptfds</code></p>
<p>其余条件的文件描述符集合。包括：</p>
<ul>
<li>TCP套接字有带外数据</li>
<li>处于包模式下的伪终端的主端检测到从端的状态变化</li>
<li><code>cgroup.events</code>文件被修改</li>
</ul>
</li>
</ul>
<p>如果对相应的状态变化不感兴趣，在对应的参数中传递<code>NULL</code>即可。</p>
<p>我们可以用以下几个函数操作<code>fd_set</code>类型的变量：</p>
<pre><code class="language-c">void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
</code></pre>
<ul>
<li>
<p><code>FD_ZERO</code></p>
<p>将<code>set</code>清空</p>
</li>
<li>
<p><code>FD_SET</code></p>
<p>将<code>fd</code>放入<code>set</code>中</p>
</li>
<li>
<p><code>FD_CLR</code></p>
<p>将<code>fd</code>从<code>set</code>中移除</p>
</li>
<li>
<p><code>FD_ISSET</code></p>
<p>判断<code>fd</code>是否处于<code>set</code>中</p>
</li>
</ul>
<p><code>nfds</code>为<code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>中，数值最大的文件描述符加1。如<code>readfds</code>包含文件描述符4, 6, 7，<code>writefds</code>包含文件描述符5，<code>exceptfds</code>为空，则<code>nfds</code>为8。</p>
<p><code>timeout</code>为超时参数，其结构为</p>
<pre><code class="language-c">struct timeval {
    time_t      tv_sec;         /* seconds */
    suseconds_t tv_usec;        /* microseconds */
};
</code></pre>
<p>如果<code>timeout</code>指针为<code>NULL</code>，则<code>select</code>将一直等待，直到有一个文件描述符准备好。如果<code>tv_sec</code>和<code>tv_usec</code>均为0，则<code>select</code>将立即返回。否则，<code>select</code>如果等待达到<code>timeout</code>的时间，还没有任何文件描述符准备好，就返回。</p>
<p>当函数返回之后，会有如下变化：</p>
<ul>
<li>返回值为<code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>中准备好的文件描述符的总数</li>
<li><code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>中会只保留已经处于准备好状态的文件描述符。我们可以通过<code>FD_ISSET</code>去查看哪些文件描述符准备好。（正因如此，如果我们在一个循环中使用<code>select</code>，那在每次使用之前，需要复制一遍各集合，或用<code>FD_CLR</code>清空后重新添加）</li>
<li><code>select</code>可能会更新<code>timeout</code>参数。</li>
</ul>
<p>综上，如果我们要用<code>select</code>，按第三个方案来实现我们的功能，其写法为</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    fd_set rset;
    FD_ZERO(&amp;rset);
    int maxfd = -1;
    for (int i = 0; i &lt; nfd; i++) {
        FD_SET(fds[i], &amp;rset);
        if (fds[i] &gt; maxfd) {
            maxfd = fds[i];
        }
    }
    while (1) {
        fd_set tmp_rset;
        memcpy(&amp;tmp_rset, &amp;rset, sizeof(fd_set));
        if (select(maxfd + 1, &amp;tmp_rset, NULL, NULL, NULL) &lt;= 0) {
            break;
        }
        for (int i = 0; i &lt; nfd; i++) {
            if (FD_ISSET(fds[i], &amp;tmp_rset)) {
                FD_CLR(fds[i], &amp;rset);
                char buf[64];
                read(fds[i], buf, 64);
                process_read_content(buf);
            }
        }
    }
}
</code></pre>
<p>此外，值得注意的是，glibc的封装要求我们的文件描述符的值不能超过<code>FD_SETSIZE</code>，也就是1024。</p>
<h4 id="poll"><a class="header" href="#poll"><code>poll</code></a></h4>
<p><code>poll</code>的函数签名为</p>
<pre><code class="language-c">int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre>
<p>与<code>select</code>不同的是，它并不是把文件描述符放在<code>fd_set</code>结构体中，而是放在一个<code>struct pollfd</code>类型组成的数组中，<code>nfds</code>为该数组的长度。</p>
<p><code>struct pollfd</code>的定义为</p>
<pre><code class="language-c">struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};
</code></pre>
<p><code>fd</code>是文件描述符，<code>events</code>是用户感兴趣的事件（类似于<code>select</code>中的<code>readfds</code>, <code>writefds</code>和<code>exceptfds</code>），由用户填写；<code>revents</code>是实际发生的事件，由内核填写。</p>
<p><code>events</code>与<code>revents</code>是位掩码，其可以包含的标志位有</p>
<ul>
<li>
<p><code>POLLIN</code>：存在数据可以读入（相当于<code>select</code>中的<code>readfds</code>）</p>
</li>
<li>
<p><code>POLLPRI</code>：存在其他条件满足（相当于<code>select</code>中的<code>exceptfds</code>）</p>
</li>
<li>
<p><code>POLLOUT</code>：存在数据可以写入（相当于<code>select</code>中的<code>writefds</code>）</p>
</li>
<li>
<p><code>POLLRDHUP</code></p>
<p>流套接字对端关闭连接。</p>
<p>需定义<code>_GNU_SOURCE</code>宏。</p>
</li>
<li>
<p><code>POLLERR</code></p>
<p>出错。</p>
<p>只可由<code>revents</code>包含，不可由<code>events</code>包含</p>
</li>
<li>
<p><code>POLLHUP</code></p>
<p>挂起。</p>
<p>只可由<code>revents</code>包含，不可由<code>events</code>包含</p>
</li>
<li>
<p><code>POLLNVAL</code></p>
<p>由于<code>fd</code>未打开，请求无效。</p>
<p>只可由<code>revents</code>包含，不可由<code>events</code>包含</p>
</li>
</ul>
<p>当<code>events</code>为0时，<code>revents</code>只可返回<code>POLLERR</code>, <code>POLLHUP</code>和<code>POLLNVAL</code>（将<code>events</code>置为0类似于<code>select</code>中的<code>FD_CLR</code>）。若其不为0，则可以返回<code>events</code>中包含的事件，以及<code>POLLERR</code>, <code>POLLHUP</code>和<code>POLLNVAL</code>。如果返回的<code>revents</code>为0，则表示什么都没发生，可能超时了，或者别的文件描述符中发生了用户感兴趣的事。</p>
<p><code>timeout</code>参数表示其最多等待时间（以毫秒为单位）。如果其为负，则表示<code>poll</code>无限等待；如果其为0，则表示<code>poll</code>立即返回。</p>
<p>如果在超时范围内，任何一个用户感兴趣的事件发生了，<code>poll</code>将会返回，返回值为产生用户感兴趣事件的文件描述符个数；如果超时了，没有任何一个用户感兴趣的事件发生，则<code>poll</code>将会返回0。</p>
<p>综上，如果我们要用<code>poll</code>，按第三个方案来实现我们的功能，其写法为</p>
<pre><code class="language-c">void process_fds(int *fds, int nfd) {
    struct pollfd *pollfds = (struct pollfd *)malloc(nfd * sizeof(struct pollfd));
    for (int i = 0; i &lt; nfd; i++) {
        pollfds[i].fd = fds[i];
        pollfds[i].events = POLLIN;
    }
    while (1) {
        if (poll(pollfds, nfd, -1) &lt;= 0) {
            break;
        }
        for (int i = 0; i &lt; nfd; i++) {
            if (pollfds[i].revents &amp; POLLIN) {
                pollfds[i].events = 0;
                char buf[64];
                read(fds[i], buf, 64);
                process_read_content(buf);
            }
        }
    }
}
</code></pre>
<p>与<code>select</code>不同的是，其可以包含的文件描述符个数无上限。</p>
<p>根据上述的讨论，<code>poll</code>与<code>select</code>的区别在于</p>
<ul>
<li><code>poll</code>文件描述符个数无上限，<code>select</code>文件描述符其值上限为<code>FD_SETSIZE</code></li>
<li><code>poll</code>感兴趣的事件种类更多</li>
<li><code>poll</code>不需要在每次调用前都复制一遍<code>fd_set</code>，也就是<code>poll</code>不会改变传入的<code>fds</code>。</li>
<li><code>poll</code>超时参数精度为毫秒，<code>select</code>超时参数精度为微秒，<code>select</code>更精确。</li>
</ul>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<h4 id="select-1"><a class="header" href="#select-1"><code>select</code></a></h4>
<p>首先我们来看看<code>fd_set</code>与和其相关的函数是怎么实现的。在Linux内核的<code>include/linux/types.h</code>中可以看到</p>
<pre><code class="language-c">typedef __kernel_fd_set		fd_set;
</code></pre>
<p>而在<code>include/uapi/linux/posix_types.h</code>中可以看到</p>
<pre><code class="language-c">#define __FD_SETSIZE	1024

typedef struct {
	unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
} __kernel_fd_set;
</code></pre>
<p>所以，这其实就是一个长度为1024字节的位数组。同时我们也明白了，为什么<code>select</code>要求文件描述符的值不能超过<code>FD_SETSIZE</code>。</p>
<p>同时，我们也可以在glibc的源码<code>misc/sys/select.h</code>中看到和其相关的函数的定义</p>
<pre><code class="language-c">#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)
</code></pre>
<p>其实现则位于<code>bits/select.h</code>：</p>
<pre><code class="language-c">#define __FD_ZERO(s) \
  do {									      \
    unsigned int __i;							      \
    fd_set *__arr = (s);						      \
    for (__i = 0; __i &lt; sizeof (fd_set) / sizeof (__fd_mask); ++__i)	      \
      __FDS_BITS (__arr)[__i] = 0;					      \
  } while (0)
#define __FD_SET(d, s) \
  ((void) (__FDS_BITS (s)[__FD_ELT(d)] |= __FD_MASK(d)))
#define __FD_CLR(d, s) \
  ((void) (__FDS_BITS (s)[__FD_ELT(d)] &amp;= ~__FD_MASK(d)))
#define __FD_ISSET(d, s) \
  ((__FDS_BITS (s)[__FD_ELT (d)] &amp; __FD_MASK (d)) != 0)
</code></pre>
<p>简单来说，就是：</p>
<ul>
<li><code>FD_ZERO</code>将整个位数组清0（不用<code>memset</code>的原因是，这可能需要在之前声明<code>memset</code>的原型，并且这个数组其实并不大）</li>
<li><code>FD_SET</code>将该文件描述符对应的比特位置1</li>
<li><code>FD_CLR</code>将该文件描述符对应的比特位置0</li>
<li><code>FD_ISSET</code>判断该文件描述符对应的比特位是否为1</li>
</ul>
<p>接着，我们来看看<code>select</code>内部的实现。其实现均位于Linux内核源码的<code>fs/select.c</code>文件中。</p>
<p>首先，在<code>core_sys_select</code>函数里，使用了一个<code>fd_set_bits</code>的结构体，其定义为：</p>
<pre><code class="language-c">typedef struct {
	unsigned long *in, *out, *ex;
	unsigned long *res_in, *res_out, *res_ex;
} fd_set_bits;
</code></pre>
<p>一共六个位数组，前三个是存储我们传入的参数的，后三个存储结果，在最终再复制进前三个中。</p>
<p><code>select</code>的实现，最主要的就是<code>do_select</code>函数，其内容非常长，但也十分重要：</p>
<pre><code class="language-c">static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)
{
	ktime_t expire, *to = NULL;
	struct poll_wqueues table;
	poll_table *wait;
	int retval, i, timed_out = 0;
	u64 slack = 0;
	__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
	unsigned long busy_start = 0;

	rcu_read_lock();
	retval = max_select_fd(n, fds);
	rcu_read_unlock();

	if (retval &lt; 0)
		return retval;
	n = retval;

	poll_initwait(&amp;table);
	wait = &amp;table.pt;
	if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) {
		wait-&gt;_qproc = NULL;
		timed_out = 1;
	}

	if (end_time &amp;&amp; !timed_out)
		slack = select_estimate_accuracy(end_time);

	retval = 0;
	for (;;) {
		unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;
		bool can_busy_loop = false;

		inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;
		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;

		for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) {
			unsigned long in, out, ex, all_bits, bit = 1, j;
			unsigned long res_in = 0, res_out = 0, res_ex = 0;
			__poll_t mask;

			in = *inp++; out = *outp++; ex = *exp++;
			all_bits = in | out | ex;
			if (all_bits == 0) {
				i += BITS_PER_LONG;
				continue;
			}

			for (j = 0; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= 1) {
				struct fd f;
				if (i &gt;= n)
					break;
				if (!(bit &amp; all_bits))
					continue;
				f = fdget(i);
				if (f.file) {
					wait_key_set(wait, in, out, bit,
						     busy_flag);
					mask = vfs_poll(f.file, wait);

					fdput(f);
					if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {
						res_in |= bit;
						retval++;
						wait-&gt;_qproc = NULL;
					}
					if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {
						res_out |= bit;
						retval++;
						wait-&gt;_qproc = NULL;
					}
					if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {
						res_ex |= bit;
						retval++;
						wait-&gt;_qproc = NULL;
					}
					/* got something, stop busy polling */
					if (retval) {
						can_busy_loop = false;
						busy_flag = 0;

					/*
					 * only remember a returned
					 * POLL_BUSY_LOOP if we asked for it
					 */
					} else if (busy_flag &amp; mask)
						can_busy_loop = true;

				}
			}
			if (res_in)
				*rinp = res_in;
			if (res_out)
				*routp = res_out;
			if (res_ex)
				*rexp = res_ex;
			cond_resched();
		}
		wait-&gt;_qproc = NULL;
		if (retval || timed_out || signal_pending(current))
			break;
		if (table.error) {
			retval = table.error;
			break;
		}

		/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */
		if (can_busy_loop &amp;&amp; !need_resched()) {
			if (!busy_start) {
				busy_start = busy_loop_current_time();
				continue;
			}
			if (!busy_loop_timeout(busy_start))
				continue;
		}
		busy_flag = 0;

		/*
		 * If this is the first loop and we have a timeout
		 * given, then we convert to ktime_t and set the to
		 * pointer to the expiry value.
		 */
		if (end_time &amp;&amp; !to) {
			expire = timespec64_to_ktime(*end_time);
			to = &amp;expire;
		}

		if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,
					   to, slack))
			timed_out = 1;
	}

	poll_freewait(&amp;table);

	return retval;
}
</code></pre>
<p><code>fd_set_bits</code>类型的<code>fds</code>，其表示输入的字段复制于系统调用的输入，其表示输出的字段在调用前被清空。</p>
<p>其主体部分为两层嵌套的循环。在最外层循环中，每一轮循环处理<code>BITS_PER_LONG</code>，也就是一般来说64个文件描述符。这是因为我们的数据是用<code>long</code>的位数组来存储的，所以这样分批次效率更高。在内循环中，我们遍历这个<code>long</code>整型的每个字节，其每个字节对应一个文件描述符。</p>
<p>也就是说，我们从0开始，一直到我们传入系统调用的参数<code>n</code>，也就是最大的文件描述符的值，遍历每个文件描述符，在在53行看到，通过<code>bit &amp; all_bits</code>，判断当前的文件描述符是否在我们之前传入的<code>in</code>, <code>out</code>或<code>ex</code>集合中。对于存在集合中的，最终调用了<code>vfs_poll</code>来查询单个文件的状态，其实现位于<code>fs/poll.h</code>中：</p>
<pre><code class="language-c">static inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt)
{
	if (unlikely(!file-&gt;f_op-&gt;poll))
		return DEFAULT_POLLMASK;
	return file-&gt;f_op-&gt;poll(file, pt);
}
</code></pre>
<p>依旧是函数指针模拟多态。</p>
<p>最终，再把<code>res_in</code>, <code>res_out</code>, <code>res_ex</code>复制回原本的<code>in</code>, <code>out</code>, <code>ex</code>即可。</p>
<p>总的来说，<code>select</code>的步骤是，对于输入的参数<code>nfds</code>，把值从0到<code>nfds - 1</code>的所有相关的文件描述符都查询一遍，对于每个文件描述符，调用<code>vfs_poll</code>查询状态。</p>
<h4 id="poll-1"><a class="header" href="#poll-1"><code>poll</code></a></h4>
<p><code>poll</code>的实现位于<code>fs/select.c</code>，其核心<code>do_poll</code>依然很长，但也十分重要：</p>
<pre><code class="language-c">static int do_poll(struct poll_list *list, struct poll_wqueues *wait, struct timespec64 *end_time)
{
	poll_table* pt = &amp;wait-&gt;pt;
	ktime_t expire, *to = NULL;
	int timed_out = 0, count = 0;
	u64 slack = 0;
	__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
	unsigned long busy_start = 0;

	/* Optimise the no-wait case */
	if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) {
		pt-&gt;_qproc = NULL;
		timed_out = 1;
	}

	if (end_time &amp;&amp; !timed_out)
		slack = select_estimate_accuracy(end_time);

	for (;;) {
		struct poll_list *walk;
		bool can_busy_loop = false;

		for (walk = list; walk != NULL; walk = walk-&gt;next) {
			struct pollfd * pfd, * pfd_end;

			pfd = walk-&gt;entries;
			pfd_end = pfd + walk-&gt;len;
			for (; pfd != pfd_end; pfd++) {
				/*
				 * Fish for events. If we found one, record it
				 * and kill poll_table-&gt;_qproc, so we don't
				 * needlessly register any other waiters after
				 * this. They'll get immediately deregistered
				 * when we break out and return.
				 */
				if (do_pollfd(pfd, pt, &amp;can_busy_loop,
					      busy_flag)) {
					count++;
					pt-&gt;_qproc = NULL;
					/* found something, stop busy polling */
					busy_flag = 0;
					can_busy_loop = false;
				}
			}
		}
		/*
		 * All waiters have already been registered, so don't provide
		 * a poll_table-&gt;_qproc to them on the next loop iteration.
		 */
		pt-&gt;_qproc = NULL;
		if (!count) {
			count = wait-&gt;error;
			if (signal_pending(current))
				count = -ERESTARTNOHAND;
		}
		if (count || timed_out)
			break;

		/* only if found POLL_BUSY_LOOP sockets &amp;&amp; not out of time */
		if (can_busy_loop &amp;&amp; !need_resched()) {
			if (!busy_start) {
				busy_start = busy_loop_current_time();
				continue;
			}
			if (!busy_loop_timeout(busy_start))
				continue;
		}
		busy_flag = 0;

		/*
		 * If this is the first loop and we have a timeout
		 * given, then we convert to ktime_t and set the to
		 * pointer to the expiry value.
		 */
		if (end_time &amp;&amp; !to) {
			expire = timespec64_to_ktime(*end_time);
			to = &amp;expire;
		}

		if (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))
			timed_out = 1;
	}
	return count;
}
</code></pre>
<p>传入的参数<code>list</code>的类型是<code>struct poll_list</code>的指针：</p>
<pre><code class="language-c">struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};
</code></pre>
<p>也就是说，这里是一个链表。其<code>entries</code>字段是一个变长数组。我们传入<code>do_poll</code>的<code>list</code>参数是将传入系统调用的<code>fds</code>，也就是由<code>nfds</code>个<code>struct pollfd</code>类型的实例组成的数组，在之前的<code>do_sys_poll</code>函数中，被分成长度为<code>POLLFD_PER_PAGE</code>的若干个部分，然后再将每个部分用链表串联起来。这样做的原因应该就是保证每次处理的一批不会超过页大小，尽量减少换页。</p>
<p>在<code>do_poll</code>函数中我们可以看到，对每个链表项，遍历了其<code>entries</code>数组，也就相当于对我们传入的<code>fds</code>进行遍历。对每一个文件描述符，使用<code>do_pollfd(pfd, pt, &amp;can_busy_loop, busy_flag)</code>来进行真正的<code>poll</code>操作，而<code>do_pollfd</code>，实际上就是调用的<code>vfs_poll</code>。</p>
<h2 id="pselect6与ppoll"><a class="header" href="#pselect6与ppoll"><code>pselect6</code>与<code>ppoll</code></a></h2>
<h3 id="系统调用号-1"><a class="header" href="#系统调用号-1">系统调用号</a></h3>
<p><code>pselect6</code>为270，<code>ppoll</code>为271。</p>
<h3 id="函数签名"><a class="header" href="#函数签名">函数签名</a></h3>
<h4 id="内核接口-1"><a class="header" href="#内核接口-1">内核接口</a></h4>
<pre><code class="language-c">asmlinkage long sys_pselect6(int, fd_set __user *, fd_set __user *, fd_set __user *, struct __kernel_timespec __user *, void __user *);
asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int, struct __kernel_timespec __user *, const sigset_t __user *, size_t);
</code></pre>
<h4 id="glibc封装-1"><a class="header" href="#glibc封装-1">glibc封装</a></h4>
<p><code>pselect6</code></p>
<pre><code class="language-c">#include &lt;sys/select.h&gt;
int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout,  const sigset_t *sigmask);
</code></pre>
<p><code>ppoll</code></p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;signal.h&gt;
#include &lt;poll.h&gt;
int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask);
</code></pre>
<h3 id="简介-1"><a class="header" href="#简介-1">简介</a></h3>
<p><code>pselect</code>与<code>select</code>的区别主要在于：</p>
<ul>
<li>超时精度
<ul>
<li><code>select</code>使用的是<code>struct timeval</code>结构体，精确到微秒</li>
<li><code>pselect</code>使用的是<code>struct timespec</code>结构体，精确到纳秒</li>
</ul>
</li>
<li>超时参数
<ul>
<li><code>select</code>可能会更新其超时参数<code>timeout</code></li>
<li><code>pselect6</code>系统调用可能会更新其超时参数，glibc的封装<code>pselect</code>不会更新其超时参数</li>
</ul>
</li>
<li>信号掩码
<ul>
<li><code>pselect</code>可以设置信号掩码，若其为<code>NULL</code>，则行为与<code>select</code>相同</li>
</ul>
</li>
</ul>
<p><code>ppoll</code>与<code>poll</code>的区别主要在于：</p>
<ul>
<li>超时精度
<ul>
<li><code>poll</code>使用的超时精度为毫秒</li>
<li><code>ppoll</code>使用的是<code>struct timespec</code>结构体，精确到纳秒</li>
</ul>
</li>
<li>信号掩码
<ul>
<li><code>ppoll</code>可以设置信号掩码，若其为<code>NULL</code>，则行为与<code>poll</code>相同</li>
</ul>
</li>
</ul>
<p><code>pselect</code>与<code>ppoll</code>可以看作执行<code>select</code>或<code>poll</code>前后设置信号掩码。之所以需要这两个单独的系统调用，是因为如果我们的需求是，要么接收到特定的信号，要么某个文件描述符准备好，然后执行后续的操作。如果我们分为两步操作，但是接受信号实际上是在判断是否接收到信号之后，也就是判断结果为没接收到信号，而且在调用<code>select</code>之前，那么就可能陷入无限等待。<code>pselect</code>与<code>ppoll</code>进行信号判断的时候则是使用原子操作，所以不会产生这样的竞争条件。</p>
<h3 id="实现-1"><a class="header" href="#实现-1">实现</a></h3>
<p><code>pselect6</code>与<code>ppoll</code>在Linux内核中的实现与<code>select</code>和<code>poll</code>类似。有一点需要说明的是，<code>pselect6</code>接受的最后一个参数是<code>void *</code>类型的，这是因为它实际上需要的类型为</p>
<pre><code class="language-c">struct {
    const kernel_sigset_t *ss;   /* Pointer to signal set */
    size_t ss_len;               /* Size (in bytes) of object
                                    pointed to by 'ss' */
};
</code></pre>
<p>本来其实可以把这两个字段变成两个函数的参数的，但由于Linux x86_64的ABI要求系统调用至多只能接受6个参数，所以最后一个参数只能是这样的结构体了。</p>
<p>值得注意的是，在glibc的封装中，以<code>pselect</code>为例：</p>
<p>我们在glibc源码的<code>sysdeps/unix/sysv/linux/pselect.c</code>中可以看到：</p>
<pre><code class="language-c">int
__pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	   const struct timespec *timeout, const sigset_t *sigmask)
{
  /* The Linux kernel can in some situations update the timeout value.
     We do not want that so use a local variable.  */
  struct timespec tval;
  if (timeout != NULL)
    {
      tval = *timeout;
      timeout = &amp;tval;
    }

  /* Note: the system call expects 7 values but on most architectures
     we can only pass in 6 directly.  If there is an architecture with
     support for more parameters a new version of this file needs to
     be created.  */
  struct
  {
    __syscall_ulong_t ss;
    __syscall_ulong_t ss_len;
  } data;

  data.ss = (__syscall_ulong_t) (uintptr_t) sigmask;
  data.ss_len = _NSIG / 8;

  return SYSCALL_CANCEL (pselect6, nfds, readfds, writefds, exceptfds,
                         timeout, &amp;data);
}
</code></pre>
<p>通过设置一个局部变量<code>tval</code>，使得传入的参数<code>timeout</code>不会被内核修改。<code>ppoll</code>也进行了类似的操作。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../src/filesystem/lseek.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../src/filesystem/lseek.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../src/filesystem/epoll_create-epoll_wait-epoll_ctl-epoll_pwait-epoll_create1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
